<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Election Data Visualization</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- SQL.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    
    <style>
        body, html {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        
        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .app-title {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        
        .app-title h1 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .app-title p {
            margin: 5px 0 0 0;
            font-size: 12px;
            color: #666;
        }
        
        .controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 280px;
        }
        
        .database-section {
            margin-bottom: 15px;
        }
        
        .database-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .database-section input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 12px;
        }
        
        .database-section button {
            background: #3388ff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        
        .database-section button:hover {
            background: #2b75e5;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 12px;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            background-color: white;
            box-sizing: border-box;
        }
        
        .status-messages {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 70%;
            max-width: 500px;
        }
        
        .loading, .error, .success {
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0.95;
        }
        
        .loading {
            background-color: #f8f9fa;
            color: #333;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            max-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .layer-control {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            max-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .layer-control h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .layer-list {
            margin-bottom: 10px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: #f8f8f8;
            border-radius: 3px;
        }
        
        .layer-item button {
            margin-left: auto;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .layer-actions {
            margin-top: 10px;
        }
        
        .layer-actions button {
            background: #3388ff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .color-box {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .leaflet-popup-content {
            min-width: 200px;
        }
        
        .popup-content h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 16px;
        }
        
        .popup-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .popup-content th {
            text-align: left;
            padding: 4px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }
        
        .popup-content td {
            padding: 4px;
            border-bottom: 1px solid #f5f5f5;
        }
        
        .footer {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 0, 0, 0.6);
            font-size: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="app-title">
        <h1>Election Data Visualization</h1>
        <p>Interactive exploration of global election results</p>
    </div>
    
    <div class="controls-panel">
        <div class="database-section">
            <h3>Database Connection</h3>
            <input type="text" id="database-url" placeholder="Enter SQLite file URL" value="https://storage.googleapis.com/sage_archive/Albania.sqlite">
            <button id="load-database">Load Database</button>
        </div>
        
        <div class="control-group">
            <label for="country-select">Country</label>
            <select id="country-select" disabled>
                <option value="">Select Country</option>
                <!-- Countries will be populated dynamically -->
            </select>
        </div>
        
        <div class="control-group">
            <label for="year-select">Year</label>
            <select id="year-select" disabled>
                <option value="">Select Year</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="election-type-select">Election Type</label>
            <select id="election-type-select" disabled>
                <option value="">Select Election Type</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="display-mode">Display Mode</label>
            <select id="display-mode">
                <option value="points">Points</option>
                <option value="polygons" disabled>Polygons (currently unavailable)</option>
                <option value="both" disabled>Both Points & Polygons (currently unavailable)</option>
            </select>
        </div>
    </div>
    
    <div class="status-messages">
        <div id="loading" class="loading" style="display: none;">
            Loading data, please wait...
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="success" class="success" style="display: none;"></div>
    </div>
    
    <div class="layer-control" id="layer-control">
        <h4>Map Layers</h4>
        <div id="layer-list" class="layer-list">
            <!-- Layer items will be added here dynamically -->
            <div class="empty-message">No active layers</div>
        </div>
        <div class="layer-actions">
            <button id="add-current-layer">Add Current Selection</button>
            <button id="clear-all-layers">Clear All</button>
        </div>
        <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <label for="scale-points-toggle" style="flex-grow: 1; font-size: 13px;">Scale Points by Votes:</label>
                <input type="checkbox" id="scale-points-toggle" checked>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <label for="opacity-toggle" style="flex-grow: 1; font-size: 13px;">Solid Points (No Transparency):</label>
                <input type="checkbox" id="opacity-toggle" checked>
            </div>
        </div>
    </div>
    
    <div class="footer">
        &copy; Election Data Visualization - 2025
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global variables
        let map;
        let SQL;
        let db;
        let partyColors = {};
        let legendControl;
        let markersLayer;
        let displayMode = 'points'; // Only points mode is available
        let coordGroups = {}; // Store coordinate groups for map data
        let allLocations = []; // Store all processed locations
        let scalePointsByVotes = true; // Whether to scale points by vote count
        let useSolidPoints = true; // Whether to use solid points (no transparency)
        let activeLayers = []; // Store active country layers
        
        // Variables for CSV-based approach
        let useCSVMode = true; // Whether to use CSV files instead of SQLite
        let countriesIndex = []; // Main countries index
        let currentCountryIndex = []; // Index for currently selected country
        let countryBasePath = ''; // Base path for country data files
        
        // Coordinate conversion functions for dealing with projections
        
        // Convert WGS84 lat/lng to Web Mercator (EPSG:3857)
        function latLngToMercator(lat, lng) {
            // Constants
            const EARTH_RADIUS = 6378137; // Earth's radius in meters
            
            // Convert to radians
            const latRad = lat * Math.PI / 180;
            const lngRad = lng * Math.PI / 180;
            
            // Calculate mercator coordinates
            const mercatorX = EARTH_RADIUS * lngRad;
            const mercatorY = EARTH_RADIUS * Math.log(Math.tan(Math.PI / 4 + latRad / 2));
            
            return { mercatorX, mercatorY };
        }
        
        // Convert Web Mercator (EPSG:3857) to WGS84 lat/lng
        function mercatorToLatLng(x, y) {
            // Constants
            const EARTH_RADIUS = 6378137; // Earth's radius in meters
            
            // Calculate lat/lng in radians
            const lngRad = x / EARTH_RADIUS;
            const latRad = 2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2;
            
            // Convert to degrees
            const lat = latRad * 180 / Math.PI;
            const lng = lngRad * 180 / Math.PI;
            
            return { lat, lng };
        }
        
        // More contrasting color palette with no yellows and better visual differentiation
        // Reordered with most distinctive colors first and purple moved down
        const colorPalette = [
            '#D32F2F', // Bright red
            '#1976D2', // Strong blue
            '#388E3C', // Deep green
            '#F57C00', // Orange
            '#C2185B', // Magenta
            '#0097A7', // Teal
            '#455A64', // Blue Gray
            '#7B1FA2', // Purple
            '#5D4037', // Brown
            '#00796B', // Dark Teal
            '#6D4C41', // Dark Brown
            '#512DA8', // Deep Purple
            '#004D40', // Darkest Teal
            '#3E2723', // Darkest Brown  
            '#263238'  // Darkest Blue Gray
        ];
        
        // DOM elements
        const databaseUrlInput = document.getElementById('database-url');
        const loadDatabaseButton = document.getElementById('load-database');
        const countrySelect = document.getElementById('country-select');
        const yearSelect = document.getElementById('year-select');
        const electionTypeSelect = document.getElementById('election-type-select');
        const displayModeSelect = document.getElementById('display-mode');
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('error');
        const successElement = document.getElementById('success');
        
        // Initialize the map
        function initializeMap() {
            // Create the map - default to world view
            map = L.map('map').setView([20, 0], 2); // Centered on world by default
            
            // Add a simple light base map by default
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>',
                // Uses Web Mercator (EPSG:3857) projection by default
                // So we'll use that to match our data
                tms: false,
                detectRetina: true
            }).addTo(map);
            
            // Create layers for markers
            markersLayer = L.layerGroup();
            
            // Add marker layer
            markersLayer.addTo(map);
            
            // Initialize SQL.js
            initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            }).then(sqlJs => {
                SQL = sqlJs;
                loadDatabaseButton.disabled = false;
            }).catch(error => {
                showError(`Failed to initialize SQL.js: ${error.message}`);
            });
            
            // Set up event listeners
            loadDatabaseButton.addEventListener('click', handleLoadDatabase);
            displayModeSelect.addEventListener('change', function() {
                displayMode = displayModeSelect.value;
                if (electionTypeSelect.value) {
                    // If we already have data loaded, update the view
                    updateDisplayLayers();
                }
            });
        }
        
        // Handle database loading from cloud URL
        async function handleLoadDatabase() {
            const databaseUrl = databaseUrlInput.value.trim();
            
            if (!databaseUrl) {
                showError('Please enter a valid URL to your SQLite file.');
                return;
            }
            
            try {
                showLoading(true);
                hideError();
                hideSuccess();
                
                console.log("Loading database from URL:", databaseUrl);
                
                // Clear previous data
                clearMap();
                resetSelects();
                
                await loadDatabase(databaseUrl);
                
                showSuccess('Database loaded successfully!');
                showLoading(false);
            } catch (error) {
                showError(`Failed to load database: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Handle country selection change
        async function handleCountryChange() {
            const selectedCountry = countrySelect.value;
            
            if (!selectedCountry) {
                resetSelects();
                clearMap();
                return;
            }
            
            try {
                showLoading(true);
                hideError();
                
                // Reset year and election type selects
                yearSelect.innerHTML = '<option value="">Select Year</option>';
                yearSelect.disabled = true;
                
                electionTypeSelect.innerHTML = '<option value="">Select Election Type</option>';
                electionTypeSelect.disabled = true;
                
                // Load available years for this country
                await loadYears(selectedCountry);
                
                showLoading(false);
            } catch (error) {
                showError(`Failed to load data for ${selectedCountry}: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Load the SQLite database from URL
        async function loadDatabase(url) {
            try {
                // Add a cache-busting parameter to avoid browser caching
                const cacheBusterUrl = `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}`;
                
                const response = await fetch(cacheBusterUrl, {
                    method: 'GET',
                    mode: 'cors', // This is important for cross-origin requests
                    cache: 'no-cache' // Avoid caching
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                db = new SQL.Database(new Uint8Array(arrayBuffer));
                
                // Load available countries
                await loadCountries();
                
                return db;
            } catch (error) {
                throw new Error(`Failed to load database: ${error.message}`);
            }
        }
        
        // Load available countries from the database
        async function loadCountries() {
            try {
                // Get tables from database
                const tablesResult = db.exec("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'");
                
                if (!tablesResult || !tablesResult.length || !tablesResult[0].values || !tablesResult[0].values.length) {
                    showError('No tables found in the database.');
                    return;
                }
                
                const tables = tablesResult[0].values.map(row => row[0]);
                console.log("Available tables:", tables);
                
                // Look for country data tables
                const countryTables = tables.filter(table => {
                    // Skip common non-data tables
                    if (['spatial_ref_sys', 'geometry_columns', 'spatial_ref_sys_all'].includes(table)) {
                        return false;
                    }
                    
                    // Check if this is a data table with elections data
                    try {
                        const result = db.exec(`SELECT COUNT(*) FROM ${table} LIMIT 1`);
                        return true;
                    } catch (e) {
                        console.error(`Error checking table ${table}:`, e);
                        return false;
                    }
                });
                
                console.log("Potential country tables:", countryTables);
                
                // Enable the country select
                countrySelect.innerHTML = '<option value="">Select Country</option>';
                countrySelect.disabled = false;
                
                // Add countries to dropdown
                countryTables.forEach(table => {
                    const option = document.createElement('option');
                    option.value = table;
                    
                    // Format the country name nicely
                    let countryName = table;
                    if (typeof countryName === 'string') {
                        // Capitalize first letter of each word
                        countryName = countryName
                            .split('_')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                            .join(' ');
                    }
                    
                    option.textContent = countryName;
                    countrySelect.appendChild(option);
                });
                
                // Add event listener for country selection
                countrySelect.removeEventListener('change', handleCountryChange);
                countrySelect.addEventListener('change', handleCountryChange);
                
            } catch (error) {
                console.error('Error loading countries:', error);
                showError(`Failed to load countries: ${error.message}`);
            }
        }
        
        // Reset select dropdowns
        function resetSelects() {
            yearSelect.innerHTML = '<option value="">Select Year</option>';
            yearSelect.disabled = true;
            
            electionTypeSelect.innerHTML = '<option value="">Select Election Type</option>';
            electionTypeSelect.disabled = true;
        }
        
        // Load available years using the country name as the table name
        async function loadYears(countryName) {
            try {
                // Check if the table exists
                const tablesResult = db.exec("SELECT name FROM sqlite_master WHERE type='table'");
                console.log("Available tables:", tablesResult);
                
                // Use the countryName directly as the table name (now that we properly load table names)
                let result;
                try {
                    // First, check what columns are available in this table
                    const columnsQuery = db.exec(`PRAGMA table_info(${countryName})`);
                    const columns = columnsQuery[0].values.map(col => col[1]);
                    console.log(`Columns for ${countryName}:`, columns);
                    
                    // Check if we have latitude/longitude columns to filter data
                    const hasLatLong = columns.includes('latitude') && columns.includes('longitude');
                    
                    if (hasLatLong) {
                        // Only get years for which we have valid coordinates
                        result = db.exec(`
                            SELECT DISTINCT year 
                            FROM ${countryName}
                            WHERE latitude IS NOT NULL 
                            AND longitude IS NOT NULL
                            AND latitude <> 'NA' 
                            AND longitude <> 'NA'
                            AND latitude <> ''
                            AND longitude <> ''
                            ORDER BY year DESC
                        `);
                    } else {
                        // If no coordinates, just get all years
                        result = db.exec(`
                            SELECT DISTINCT year 
                            FROM ${countryName}
                            ORDER BY year DESC
                        `);
                    }
                } catch (e) {
                    console.error(`Error querying years for ${countryName}:`, e);
                    throw new Error(`Could not load years for ${countryName}: ${e.message}`);
                }
                
                if (result.length === 0 || result[0].values.length === 0) {
                    showError(`No valid years with coordinate data found for ${countryName}.`);
                    return;
                }
                
                yearSelect.innerHTML = '<option value="">Select Year</option>';
                yearSelect.disabled = false;
                
                result[0].values.forEach(row => {
                    const year = row[0];
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });
                
                // Remove previous event listener if exists
                yearSelect.removeEventListener('change', handleYearChange);
                
                // Set up new event listener
                yearSelect.addEventListener('change', handleYearChange);
            } catch (error) {
                console.error(error);
                showError(`Failed to load years: ${error.message}`);
            }
        }
        
        // Handle year selection change
        async function handleYearChange() {
            const selectedYear = yearSelect.value;
            const countryName = countrySelect.value;
            
            if (!selectedYear) {
                electionTypeSelect.innerHTML = '<option value="">Select Election Type</option>';
                electionTypeSelect.disabled = true;
                clearMap();
                return;
            }
            
            try {
                showLoading(true);
                
                // Get column information
                const columnsQuery = db.exec(`PRAGMA table_info(${countryName})`);
                const columns = columnsQuery[0].values.map(col => col[1]);
                console.log(`Columns for ${countryName} (year selection):`, columns);
                
                // Check if we have latitude/longitude columns to filter data
                const hasLatLong = columns.includes('latitude') && columns.includes('longitude');
                
                // Query for election types with valid coordinates
                let result;
                if (hasLatLong) {
                    // Only get election types for which we have valid coordinates
                    result = db.exec(`
                        SELECT DISTINCT election_type 
                        FROM ${countryName}
                        WHERE year = ${selectedYear}
                        AND latitude IS NOT NULL 
                        AND longitude IS NOT NULL
                        AND latitude <> 'NA' 
                        AND longitude <> 'NA'
                        AND latitude <> ''
                        AND longitude <> ''
                    `);
                } else {
                    // If no coordinates, just get all election types
                    result = db.exec(`
                        SELECT DISTINCT election_type 
                        FROM ${countryName}
                        WHERE year = ${selectedYear}
                    `);
                }
                
                electionTypeSelect.innerHTML = '<option value="">Select Election Type</option>';
                
                if (result.length === 0 || result[0].values.length === 0) {
                    showError('No election types found for the selected year.');
                    electionTypeSelect.disabled = true;
                    showLoading(false);
                    return;
                }
                
                electionTypeSelect.disabled = false;
                
                result[0].values.forEach(row => {
                    const type = row[0];
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    electionTypeSelect.appendChild(option);
                });
                
                // Clear previous election data
                clearMap();
                
                // Remove previous event listener if exists
                electionTypeSelect.removeEventListener('change', loadElectionData);
                
                // Set up new event listener
                electionTypeSelect.addEventListener('change', loadElectionData);
                
                showLoading(false);
            } catch (error) {
                showError(`Failed to load election types: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Get the actual table name being used
        function getTableName() {
            const countryName = countrySelect.value;
            let tableName = countryName;
            
            try {
                db.exec(`SELECT * FROM ${countryName} LIMIT 1`);
            } catch (e) {
                try {
                    db.exec(`SELECT * FROM ${countryName.toLowerCase()} LIMIT 1`);
                    tableName = countryName.toLowerCase();
                } catch (e2) {
                    const tablesResult = db.exec("SELECT name FROM sqlite_master WHERE type='table'");
                    if (tablesResult.length > 0 && tablesResult[0].values.length > 0) {
                        tableName = tablesResult[0].values[0][0];
                    }
                }
            }
            
            return tableName;
        }
        
        // Load election data
        async function loadElectionData() {
            const selectedYear = yearSelect.value;
            const selectedType = electionTypeSelect.value;
            const tableName = getTableName();
            
            if (!selectedYear || !selectedType) {
                clearMap();
                return;
            }
            
            try {
                showLoading(true);
                clearMap();
                
                // Get the column names first to determine available fields
                const columnQuery = db.exec(`PRAGMA table_info(${tableName})`);
                const columns = columnQuery[0].values.map(col => col[1]);
                
                // Build dynamic query based on available columns
                let queryFields = '';
                const hasLatLong = columns.includes('latitude') && columns.includes('longitude');
                const hasGeometry = columns.includes('geometry');
                
                if (hasLatLong) {
                    queryFields += 'latitude, longitude, ';
                }
                
                if (hasGeometry) {
                    // For SQLite spatial databases, try multiple ways to extract geometry correctly
                    
                    // First try using SQLite's spatial functions to get WKT representation
                    // Different databases may use different function names
                    let wktExtracted = false;
                    
                    // Check if the database has spatial functions available
                    const spatialFunctions = [
                        'AsText', 'ST_AsText', 'AsWKT', 'ST_AsWKT', 
                        'ST_AsGeoJSON', 'AsGeoJSON', 'GeoJSON'
                    ];
                    
                    for (const func of spatialFunctions) {
                        try {
                            // Test if function exists by running a simple query
                            const testQuery = db.exec(`SELECT ${func}(NULL) LIMIT 1`);
                            // If we get here, the function exists
                            console.log(`Found spatial function: ${func}`);
                            
                            if (func.includes('GeoJSON')) {
                                queryFields += `${func}(geometry) AS geometry_json, `;
                                wktExtracted = true;
                                break;
                            } else {
                                queryFields += `${func}(geometry) AS geometry_wkt, `;
                                wktExtracted = true;
                                break;
                            }
                        } catch (e) {
                            // Function doesn't exist, try next one
                            console.log(`Spatial function ${func} not available`);
                        }
                    }
                    
                    // Always include raw geometry as backup and geometry_type
                    queryFields += 'geometry, geometry_type, ';
                    
                    // Try to get the geometry SRID as well
                    try {
                        const sridTest = db.exec(`SELECT ST_SRID(NULL) LIMIT 1`);
                        queryFields += 'ST_SRID(geometry) AS geometry_srid, ';
                    } catch (e) {
                        // SRID function not available
                    }
                }
                
                // Get all columns and build field list dynamically
                const allPossibleFields = columns;
                console.log("Available DB columns:", allPossibleFields);
                
                // Include all available fields in the query
                allPossibleFields.forEach(field => {
                    // Skip internal SQLite columns
                    if (!field.startsWith('sqlite_') && field !== 'ogc_fid') {
                        queryFields += `${field}, `;
                    }
                });
                
                // Remove trailing comma and space
                queryFields = queryFields.slice(0, -2);
                
                const result = db.exec(`
                    SELECT ${queryFields}
                    FROM ${tableName}
                    WHERE year = ${selectedYear} 
                    AND election_type = '${selectedType}'
                `);
                
                if (result.length === 0 || result[0].values.length === 0) {
                    showError('No data found for the selected criteria.');
                    showLoading(false);
                    return;
                }
                
                // Process the results
                const { columns: resultColumns, values } = result[0];
                const data = [];
                
                values.forEach(row => {
                    const item = {};
                    resultColumns.forEach((col, i) => {
                        item[col] = row[i];
                    });
                    data.push(item);
                });
                
                console.log("Starting to process election data...");
                console.log("Raw data rows:", data.length);

                // Reset global variables
                coordGroups = {}; // Use global variable
                allLocations = []; // Use global variable
                
                // Find columns for location names with more flexible detection
                const nameColumns = [];
                
                if (data.length > 0) {
                    const firstRow = data[0];
                    const allColumns = Object.keys(firstRow);
                    console.log("All columns in first row:", allColumns.join(", "));
                    
                    // Look for all columns that start with name or contain _name
                    const nameRegexes = [
                        /^name\d+(_[a-z])?$/i,  // matches name1, NAME2, name3_b, etc.
                        /^name_\w+$/i           // matches name_district, NAME_REGION, etc.
                    ];
                    
                    // Loop through all columns and check if they match our patterns
                    allColumns.forEach(column => {
                        for (const regex of nameRegexes) {
                            if (regex.test(column)) {
                                nameColumns.push(column);
                                break;
                            }
                        }
                    });
                    
                    // If we found some name columns directly, also look for suffixed versions
                    // This helps catch columns that might not follow the exact pattern
                    const detectedBaseColumns = new Set();
                    nameColumns.forEach(col => {
                        // For pattern name1, name2, etc.
                        const baseMatch = col.match(/^(name\d+)(_[a-z])?$/i);
                        if (baseMatch && baseMatch[1]) {
                            detectedBaseColumns.add(baseMatch[1].toLowerCase());
                        }
                    });
                    
                    // Now look for any suffixed versions that might have been missed
                    const suffixes = ['_b', '_c', '_d', '_e', '_f', '_g', '_h', '_i', '_j', '_k'];
                    
                    detectedBaseColumns.forEach(baseCol => {
                        suffixes.forEach(suffix => {
                            // Try variations of case
                            const candidates = [
                                baseCol + suffix,
                                baseCol.toUpperCase() + suffix,
                                baseCol.charAt(0).toUpperCase() + baseCol.slice(1) + suffix
                            ];
                            
                            candidates.forEach(candidate => {
                                if (candidate in firstRow && !nameColumns.includes(candidate)) {
                                    nameColumns.push(candidate);
                                }
                            });
                        });
                    });
                    
                    // If that fails, look for columns that contain "name" 
                    if (nameColumns.length === 0) {
                        allColumns.forEach(col => {
                            // Match columns that look like name fields
                            if (col.toLowerCase().includes('name') && 
                                !col.toLowerCase().includes('file') && // exclude filename
                                col.toLowerCase() !== 'name' && // exclude just 'name'  
                                !nameColumns.includes(col)) {
                                nameColumns.push(col);
                            }
                        });
                    }
                    
                    // Sort name columns if found
                    if (nameColumns.length > 0) {
                        nameColumns.sort((a, b) => {
                            // Extract primary numbers (name1, name2, etc.)
                            const numMatchA = a.match(/name(\d+)/i);
                            const numMatchB = b.match(/name(\d+)/i);
                            
                            const numA = numMatchA ? parseInt(numMatchA[1]) : 0;
                            const numB = numMatchB ? parseInt(numMatchB[1]) : 0;
                            
                            // If primary numbers differ, sort by them
                            if (numA !== numB) {
                                return numA - numB;
                            }
                            
                            // If same primary number, check for suffix (name3_b, name3_c, etc.)
                            // No suffix comes before any suffix
                            const hasSuffixA = a.includes('_');
                            const hasSuffixB = b.includes('_');
                            
                            if (!hasSuffixA && hasSuffixB) return -1;
                            if (hasSuffixA && !hasSuffixB) return 1;
                            
                            // Both have suffixes, sort alphabetically by suffix
                            if (hasSuffixA && hasSuffixB) {
                                const suffixA = a.split('_')[1] || '';
                                const suffixB = b.split('_')[1] || '';
                                return suffixA.localeCompare(suffixB);
                            }
                            
                            // Fallback to regular string comparison
                            return a.localeCompare(b);
                        });
                        
                        console.log("Sorted name columns:", nameColumns);
                    }
                }
                
                console.log("Found name columns:", nameColumns);
                
                // If still no name columns, let's consider alternatives
                if (nameColumns.length === 0) {
                    console.error("No NAME columns found in the data, checking for alternatives");
                    
                    // Look for fallback location columns
                    if (data.length > 0) {
                        const firstRow = data[0];
                        const fallbackCols = [];
                        
                        // Add country column if present
                        if ('country' in firstRow) {
                            fallbackCols.push('country');
                        }
                        
                        // Other possible location columns
                        ['region', 'district', 'state', 'province', 'municipality', 'city', 'locality']
                            .forEach(col => {
                                if (col in firstRow) {
                                    fallbackCols.push(col);
                                }
                            });
                        
                        if (fallbackCols.length > 0) {
                            console.log("Using fallback location columns:", fallbackCols);
                            nameColumns.push(...fallbackCols);
                        } else {
                            // Last resort - no proper location columns, but we need something
                            // Let's use 'country' if it exists at all (even if undefined in this row)
                            if ('country' in firstRow) {
                                nameColumns.push('country');
                            }
                        }
                    }
                }
                
                if (nameColumns.length === 0) {
                    console.error("No viable location name columns found in the data");
                    showError("No location name columns found in the data");
                    showLoading(false);
                    return;
                }
                
                console.log("Found NAME columns:", nameColumns);
                
                if (data.length > 0) {
                    console.log("First data row sample:", JSON.stringify(data[0]));
                }
                
                // Check if we have latitude/longitude data (case insensitive)
                let latitudeField = 'latitude';
                let longitudeField = 'longitude';
                
                // If data exists, check for fields with case sensitivity
                if (data.length > 0) {
                    const firstRow = data[0];
                    
                    // Check all possible case variations
                    if (firstRow['LATITUDE'] !== undefined) {
                        latitudeField = 'LATITUDE';
                    } else if (firstRow['Latitude'] !== undefined) {
                        latitudeField = 'Latitude';
                    }
                    
                    if (firstRow['LONGITUDE'] !== undefined) {
                        longitudeField = 'LONGITUDE';
                    } else if (firstRow['Longitude'] !== undefined) {
                        longitudeField = 'Longitude';
                    }
                }
                
                console.log(`Using coordinate fields: ${latitudeField}, ${longitudeField}`);
                
                const hasCoordinates = data.length > 0 && 
                                       data[0][latitudeField] !== undefined && 
                                       data[0][longitudeField] !== undefined;
                
                if (!hasCoordinates) {
                    showError("No geographic coordinates found in the data.");
                    console.error("No latitude/longitude columns found in data");
                    showLoading(false);
                    return;
                }
                
                // COMPLETELY NEW APPROACH:
                // 1. First group by location key (all NAMEs)
                // 2. For each location, maintain a unique set of parties
                
                // Create a map of unique locations
                const locationMap = {};
                
                // Find other important columns (case-insensitive)
                let partyField = 'party';
                let partyBField = 'party_b';
                let partyCField = 'party_c';
                let votesField = 'votes';
                let totalVotesField = 'total_votes';
                
                // Variables for registered voters (could be reg or evp)
                let regField = null;
                let hasRegisteredVoters = false;
                
                // Variables for turnout (could be turnout_reg or turnout_evp)
                let turnoutField = null;
                let hasTurnout = false;
                
                let geometryField = 'geometry';
                let geometryTypeField = 'geometry_type';
                
                // Determine actual field names from the first row
                if (data.length > 0) {
                    const firstRow = data[0];
                    const allColumns = Object.keys(firstRow);
                    
                    // Check case variations for party fields
                    if (firstRow['PARTY'] !== undefined) partyField = 'PARTY';
                    else if (firstRow['Party'] !== undefined) partyField = 'Party';
                    
                    if (firstRow['PARTY_B'] !== undefined) partyBField = 'PARTY_B';
                    else if (firstRow['Party_B'] !== undefined) partyBField = 'Party_B';
                    
                    if (firstRow['PARTY_C'] !== undefined) partyCField = 'PARTY_C';
                    else if (firstRow['Party_C'] !== undefined) partyCField = 'Party_C';
                    
                    // Check vote related fields
                    if (firstRow['VOTES'] !== undefined) votesField = 'VOTES';
                    else if (firstRow['Votes'] !== undefined) votesField = 'Votes';
                    
                    if (firstRow['TOTAL_VOTES'] !== undefined) totalVotesField = 'TOTAL_VOTES';
                    else if (firstRow['Total_Votes'] !== undefined) totalVotesField = 'Total_Votes';
                    
                    // Check for registered voters field (could be either reg or evp)
                    if (firstRow['reg'] !== undefined) {
                        regField = 'reg';
                        hasRegisteredVoters = true;
                    } else if (firstRow['REG'] !== undefined) {
                        regField = 'REG';
                        hasRegisteredVoters = true;
                    } else if (firstRow['evp'] !== undefined) {
                        regField = 'evp';
                        hasRegisteredVoters = true;
                    } else if (firstRow['EVP'] !== undefined) {
                        regField = 'EVP';
                        hasRegisteredVoters = true;
                    }
                    
                    // Check for turnout field (could be turnout_reg or turnout_evp)
                    if (firstRow['turnout_reg'] !== undefined) {
                        turnoutField = 'turnout_reg';
                        hasTurnout = true;
                    } else if (firstRow['TURNOUT_REG'] !== undefined) {
                        turnoutField = 'TURNOUT_REG';
                        hasTurnout = true;
                    } else if (firstRow['turnout_evp'] !== undefined) {
                        turnoutField = 'turnout_evp';
                        hasTurnout = true;
                    } else if (firstRow['TURNOUT_EVP'] !== undefined) {
                        turnoutField = 'TURNOUT_EVP';
                        hasTurnout = true;
                    }
                    
                    // Check geometry fields
                    if (firstRow['GEOMETRY'] !== undefined) geometryField = 'GEOMETRY';
                    else if (firstRow['Geometry'] !== undefined) geometryField = 'Geometry';
                    
                    if (firstRow['GEOMETRY_TYPE'] !== undefined) geometryTypeField = 'GEOMETRY_TYPE';
                    else if (firstRow['Geometry_Type'] !== undefined) geometryTypeField = 'Geometry_Type';
                }
                
                console.log("Using field names:", {
                    party: partyField,
                    votes: votesField,
                    totalVotes: totalVotesField
                });
                
                // Count rows with valid coordinates or geometries
                let rowsWithCoordinates = 0;
                let rowsWithGeometry = 0;
                
                data.forEach((row, index) => {
                    // Check for various forms of missing values in coordinates
                    const lat = row[latitudeField];
                    const lng = row[longitudeField];
                    
                    const isValidLat = lat !== undefined && 
                                      lat !== null && 
                                      lat !== 'NA' && 
                                      lat !== 'N/A' && 
                                      lat !== '' &&
                                      !isNaN(parseFloat(lat));
                                      
                    const isValidLng = lng !== undefined && 
                                      lng !== null && 
                                      lng !== 'NA' && 
                                      lng !== 'N/A' && 
                                      lng !== '' &&
                                      !isNaN(parseFloat(lng));
                    
                    // Check for valid geometry - accept binary objects as well as WKT
                    const geo = row[geometryField];
                    const isValidGeometry = geo !== undefined && 
                                           geo !== null && 
                                           geo !== 'NA' && 
                                           geo !== 'N/A' && 
                                           geo !== '' &&
                                           (
                                             // Check if it's a binary object (likely from SQLite)
                                             (typeof geo === 'object' && Object.keys(geo).length > 0) ||
                                             // Check if it's a string WKT format
                                             (typeof geo === 'string' && 
                                              !geo.includes('EMPTY') &&
                                              (
                                                geo.includes('POLYGON') || 
                                                geo.includes('MULTIPOLYGON') ||
                                                geo.includes('LINESTRING') ||
                                                geo.includes('POINT') ||
                                                geo.includes('(') ||  // Any WKT parenthesis
                                                geo.includes('[') ||  // Any GeoJSON brackets
                                                geo.includes('{')     // Any GeoJSON object
                                              )
                                             )
                                           );
                    
                    // Count rows with valid coordinates
                    if (isValidLat && isValidLng) {
                        rowsWithCoordinates++;
                        if (rowsWithCoordinates === 1) {
                            console.log(`First row with valid coordinates: ${index}`, 
                                `lat: ${lat}, lng: ${lng}`);
                        }
                    }
                    
                    // Count rows with valid geometries
                    if (isValidGeometry) {
                        rowsWithGeometry++;
                        if (rowsWithGeometry === 1) {
                            console.log(`First row with valid geometry: ${index}`, 
                                `geometry: ${typeof geo === 'string' ? geo.substring(0, 50) + '...' : typeof geo}`);
                        }
                    } else if (geo && typeof geo === 'string' && !geo.includes('EMPTY')) {
                        // Log some samples of geometries that didn't match our criteria
                        if (rowsWithGeometry === 0 && index < 20) { 
                            console.log(`Row ${index} - rejected geometry:`, 
                                `[${typeof geo}] ${geo.substring(0, 100)}...`);
                        }
                    }
                });
                
                console.log(`Found ${rowsWithCoordinates} rows with valid coordinates out of ${data.length} total rows`);
                console.log(`Found ${rowsWithGeometry} rows with valid geometry out of ${data.length} total rows`);
                
                // Check if we have any usable data (either coordinates or geometries)
                if (rowsWithCoordinates === 0 && rowsWithGeometry === 0) {
                    showError("No usable geographic data found. Cannot display map.");
                    showLoading(false);
                    return;
                }
                
                // If we only have geometry and no coordinates, force polygons mode
                if (rowsWithCoordinates === 0 && rowsWithGeometry > 0) {
                    displayMode = 'polygons';
                    displayModeSelect.value = 'polygons';
                    console.log("Only geometry data found, switching to polygon display mode");
                }
                
                // Process each data row
                data.forEach((row, rowIndex) => {
                    // Check coordinates
                    const lat = row[latitudeField];
                    const lng = row[longitudeField];
                    
                    const isValidLat = lat !== undefined && 
                                      lat !== null && 
                                      lat !== 'NA' && 
                                      lat !== 'N/A' && 
                                      lat !== '' &&
                                      !isNaN(parseFloat(lat));
                                      
                    const isValidLng = lng !== undefined && 
                                      lng !== null && 
                                      lng !== 'NA' && 
                                      lng !== 'N/A' && 
                                      lng !== '' &&
                                      !isNaN(parseFloat(lng));
                    
                    // Check geometry - accept binary objects as well as WKT
                    const geo = row[geometryField];
                    const isValidGeometry = geo !== undefined && 
                                           geo !== null && 
                                           geo !== 'NA' && 
                                           geo !== 'N/A' && 
                                           geo !== '' &&
                                           (
                                             // Check if it's a binary object (likely from SQLite)
                                             (typeof geo === 'object' && Object.keys(geo).length > 0) ||
                                             // Check if it's a string WKT format
                                             (typeof geo === 'string' && 
                                              !geo.includes('EMPTY') &&
                                              (
                                                geo.includes('POLYGON') || 
                                                geo.includes('MULTIPOLYGON') ||
                                                geo.includes('LINESTRING') ||
                                                geo.includes('POINT') ||
                                                geo.includes('(') ||  // Any WKT parenthesis
                                                geo.includes('[') ||  // Any GeoJSON brackets
                                                geo.includes('{')     // Any GeoJSON object
                                              )
                                             )
                                           );
                    
                    // Skip rows that have neither valid coordinates nor valid geometry
                    if ((!isValidLat || !isValidLng) && !isValidGeometry) {
                        return;
                    }
                    
                    // Create a location key from all NAME fields
                    const locationNameValues = nameColumns
                        .map(col => row[col])
                        .filter(val => val !== null && val !== undefined && val !== "");
                    
                    if (locationNameValues.length === 0) {
                        // If no name values, use the country as the name
                        if (row.country) {
                            locationNameValues.push(row.country);
                        } else {
                            console.log(`Skipping row ${rowIndex} - no NAME values and no country`);
                            return;
                        }
                    }
                    
                    const locationKey = locationNameValues.join('-');
                    
                    // Skip if no party information
                    if (!row[partyField]) {
                        console.log(`Skipping row ${rowIndex} - no party information`);
                        return;
                    }
                    
                    // If this is a new location, create it
                    if (!locationMap[locationKey]) {
                        // Create details object for NAME columns
                        const nameDetails = {};
                        nameColumns.forEach(col => {
                            if (row[col]) nameDetails[col] = row[col];
                        });
                        
                        // Create the location with basic info
                        const locationObj = {
                            key: locationKey,
                            name: locationNameValues.join(', '),
                            total_votes: parseInt(row[totalVotesField] || 0),
                            partyMap: {}, // Using an object to ensure uniqueness
                            fullDetails: nameDetails,
                            nameColumns: nameColumns
                        };
                        
                        // Add coordinates if valid
                        if (isValidLat && isValidLng) {
                            // Store original lat/lng values
                            locationObj.latitude = parseFloat(row[latitudeField]);
                            locationObj.longitude = parseFloat(row[longitudeField]);
                            
                            // Also calculate and store the Web Mercator (EPSG:3857) coordinates 
                            // This makes the points consistent with the polygon data
                            const { mercatorX, mercatorY } = latLngToMercator(
                                locationObj.latitude, 
                                locationObj.longitude
                            );
                            
                            locationObj.mercatorX = mercatorX;
                            locationObj.mercatorY = mercatorY;
                        }
                        
                        // Add geometry if valid
                        if (isValidGeometry) {
                            // Store original geometry
                            locationObj.geometry = row[geometryField];
                            
                            // Store WKT version if available
                            if (row['geometry_wkt']) {
                                locationObj.geometry_wkt = row['geometry_wkt'];
                                console.log(`Got WKT for ${locationObj.name}: ${typeof row['geometry_wkt'] === 'string' ? row['geometry_wkt'].substring(0, 50) : typeof row['geometry_wkt']}`);
                            }
                            
                            // Store GeoJSON version if available
                            if (row['geometry_json']) {
                                try {
                                    // If it's a string, try to parse it
                                    if (typeof row['geometry_json'] === 'string') {
                                        locationObj.geometry_json = JSON.parse(row['geometry_json']);
                                        console.log(`Parsed GeoJSON for ${locationObj.name}`);
                                    } else {
                                        // Otherwise store as is
                                        locationObj.geometry_json = row['geometry_json'];
                                    }
                                } catch (e) {
                                    console.error('Error parsing GeoJSON:', e);
                                    // Store as string if parsing fails
                                    locationObj.geometry_json_str = row['geometry_json'];
                                }
                            }
                            
                            // Store SRID if available
                            if (row['geometry_srid']) {
                                locationObj.geometry_srid = row['geometry_srid'];
                                console.log(`Got SRID for ${locationObj.name}: ${row['geometry_srid']}`);
                            }
                            
                            locationObj.geometry_type = row[geometryTypeField];
                        }
                        
                        // Add registered voters info if available
                        if (hasRegisteredVoters && regField) {
                            locationObj.reg = parseInt(row[regField] || 0);
                            // Store the field name used for display
                            locationObj.regField = regField;
                        }
                        
                        // Add turnout info if available
                        if (hasTurnout && turnoutField) {
                            locationObj.turnout = parseFloat(row[turnoutField] || 0);
                            // Store the field name used for display
                            locationObj.turnoutField = turnoutField;
                        }
                        
                        // Store in the location map
                        locationMap[locationKey] = locationObj;
                    }
                    
                    // Calculate vote share
                    let voteShare = 0;
                    if (row[votesField] && row[totalVotesField] && parseInt(row[totalVotesField]) > 0) {
                        voteShare = (parseInt(row[votesField]) / parseInt(row[totalVotesField])) * 100;
                    }
                    
                    // Create a party key to ensure uniqueness
                    const partyKey = row[partyField];
                    
                    // Only add this party if we haven't seen it for this location yet
                    if (!locationMap[locationKey].partyMap[partyKey]) {
                        locationMap[locationKey].partyMap[partyKey] = {
                            name: row[partyField],
                            abbreviation: row[partyBField] || '',
                            coalition: row[partyCField] || '',
                            votes: parseInt(row[votesField] || 0),
                            vote_share: voteShare
                        };
                    }
                });
                
                console.log(`Created ${Object.keys(locationMap).length} unique locations`);
                
                // Convert the partyMap to an array for each location and find the winning party
                Object.values(locationMap).forEach(location => {
                    // Convert partyMap to array
                    location.parties = Object.values(location.partyMap);
                    delete location.partyMap; // Clean up temporary map
                    
                    // Sort parties by votes (descending)
                    location.parties.sort((a, b) => b.votes - a.votes);
                    
                    // Set winning party and calculate winning share
                    if (location.parties.length > 0) {
                        location.winning_party = location.parties[0].name;
                        location.winning_votes = location.parties[0].votes;
                        
                        // Calculate winning share directly to ensure it's available
                        if (location.total_votes && location.total_votes > 0) {
                            location.winning_share = (location.parties[0].votes / location.total_votes) * 100;
                        } else {
                            location.winning_share = location.parties[0].vote_share;
                        }
                        
                        // Ensure vote_share is also calculated for each party
                        location.parties.forEach(party => {
                            if (!party.vote_share && party.votes && location.total_votes > 0) {
                                party.vote_share = (party.votes / location.total_votes) * 100;
                            }
                        });
                    }
                    
                    // Add to allLocations array
                    allLocations.push(location);
                });
                
                // Now group locations by coordinate for map display
                console.log("Grouping locations by coordinates...");
                
                // Go through all locations
                allLocations.forEach(location => {
                    // Create a coordinate key
                    const coordKey = `${location.latitude},${location.longitude}`;
                    
                    // Create the coordinate group if it doesn't exist
                    if (!coordGroups[coordKey]) {
                        coordGroups[coordKey] = {
                            latitude: location.latitude,
                            longitude: location.longitude,
                            locations: []
                        };
                    }
                    
                    // Add this location to the coordinate group
                    coordGroups[coordKey].locations.push(location);
                });
                
                console.log(`Grouped into ${Object.keys(coordGroups).length} distinct coordinates`);
                
                // Print examples for debugging
                const coordKeys = Object.keys(coordGroups);
                if (coordKeys.length > 0) {
                    const firstGroup = coordGroups[coordKeys[0]];
                    console.log(`First coordinate group at ${firstGroup.latitude},${firstGroup.longitude} has ${firstGroup.locations.length} locations`);
                    
                    if (firstGroup.locations.length > 0) {
                        const firstLocation = firstGroup.locations[0];
                        console.log(`Sample location: ${firstLocation.name}`);
                        console.log(`Sample location has ${firstLocation.parties.length} parties`);
                        if (firstLocation.parties.length > 0) {
                            console.log(`Top party: ${firstLocation.parties[0].name} with ${firstLocation.parties[0].votes} votes`);
                        }
                    }
                }
                
                // Create color mapping for parties using the correct field name
                const parties = [...new Set(data.map(item => item[partyField]).filter(Boolean))];
                console.log(`Found ${parties.length} unique parties`);
                
                parties.forEach((party, i) => {
                    partyColors[party] = colorPalette[i % colorPalette.length];
                });
                
                // Add locations to map
                renderMapData(coordGroups);
                
                // Create legend with all parties visible
                createLegend(parties);
                
                console.log("Created legend with", parties.length, "parties");
                
                // Fit map to bounds of data
                fitMapToBounds();
                
                // Force a redraw of the map to ensure points are displayed
                setTimeout(() => {
                    map.invalidateSize();
                    // Double ensure all markers are visible by redrawing them
                    updateDisplayLayers();
                }, 100);
                
                showLoading(false);
                hideError();
            } catch (error) {
                console.error(error);
                showError(`Failed to load election data: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Store visible parties
        let visibleParties = new Set(); // Will be initialized with all parties
        
        // Function to update display layers based on current display mode and party visibility
        function updateDisplayLayers() {
            // Clear existing layers
            markersLayer.clearLayers();
            
            // Safely remove layers if they're on the map
            if (map.hasLayer(markersLayer)) {
                map.removeLayer(markersLayer);
            }
            
            // Reload the data with current party colors
            if (coordGroups) {
                renderMapData(coordGroups);
            }
            
            // Add the markers layer
            map.addLayer(markersLayer);
            
            console.log(`Display mode updated: points only`);
            console.log(`Points visible: ${map.hasLayer(markersLayer)}`);
            console.log(`Marker count: ${markersLayer.getLayers().length}`);
        }
        
        // Calculate normalized brightness factor (0-1) from vote share
        function calculateNormalizedBrightness(voteShare, minVoteShare, maxVoteShare) {
            // Ensure vote share is a number
            const numericShare = parseFloat(voteShare);
            if (!numericShare || numericShare <= 0) return 0.5; // Default for missing data
            
            // Cap at 100% for calculation purposes
            const cappedShare = Math.min(numericShare, 100);
            
            // Normalize to 0-1 range based on min/max values
            let normalizedShare;
            if (maxVoteShare === minVoteShare) {
                normalizedShare = 0.5; // If all values are the same, use mid-point
            } else {
                normalizedShare = (cappedShare - minVoteShare) / (maxVoteShare - minVoteShare);
            }
            
            // Return normalized value (0 = min vote share, 1 = max vote share)
            return normalizedShare;
        }
        
        // Initialize both toggles
        function initToggles() {
            initScalePointsToggle();
            initOpacityToggle();
        }
        
        // Render the map data
        function renderMapData(coordGroups) {
            // Clear previous layers
            markersLayer.clearLayers();
            
            // Find min and max vote shares for normalization
            let minVoteShare = 100;
            let maxVoteShare = 0;
            
            // First pass to find min/max values
            Object.values(coordGroups).forEach(coordGroup => {
                const { locations } = coordGroup;
                if (locations && locations.length > 0) {
                    const firstLocation = locations[0];
                    let voteShare = 0;
                    
                    // Try to get vote share using the same logic as in the marker creation
                    if (firstLocation.winning_party) {
                        const winningParty = firstLocation.winning_party;
                        
                        if (firstLocation.winning_share) {
                            voteShare = firstLocation.winning_share;
                        } else if (firstLocation.parties && firstLocation.parties.length > 0) {
                            const party = firstLocation.parties.find(p => p.name === winningParty);
                            if (party && party.vote_share) {
                                voteShare = party.vote_share;
                            } else if (party && party.votes && firstLocation.total_votes) {
                                voteShare = (party.votes / firstLocation.total_votes) * 100;
                            }
                        }
                        
                        // Update min/max if we have a valid vote share
                        if (voteShare > 0) {
                            minVoteShare = Math.min(minVoteShare, voteShare);
                            maxVoteShare = Math.max(maxVoteShare, voteShare);
                        }
                    }
                }
            });
            
            // If we didn't find valid values, set defaults
            if (minVoteShare === 100) minVoteShare = 30;
            if (maxVoteShare === 0) maxVoteShare = 70;
            
            console.log(`Vote share range: min=${minVoteShare.toFixed(1)}%, max=${maxVoteShare.toFixed(1)}%`);
            
            // Loop through each coordinate group
            Object.values(coordGroups).forEach(coordGroup => {
                const { latitude, longitude, locations } = coordGroup;
                
                // Check if we have valid coordinates for points
                if (latitude && longitude && 
                    !isNaN(parseFloat(latitude)) && 
                    !isNaN(parseFloat(longitude))) {
                    
                    // Get the first location to determine marker size and color
                    const firstLocation = locations[0];
                    const totalVotes = locations.reduce((sum, loc) => sum + (loc.total_votes || 0), 0);
                    
                    // Find most common winning party across all locations at this coordinate
                    // Only consider parties that are currently visible
                    const partyCount = {};
                    locations.forEach(loc => {
                        if (loc.winning_party && (visibleParties.size === 0 || visibleParties.has(loc.winning_party))) {
                            partyCount[loc.winning_party] = (partyCount[loc.winning_party] || 0) + 1;
                        }
                    });
                    
                    // If no visible winning parties, skip this marker
                    if (Object.keys(partyCount).length === 0) {
                        return;
                    }
                    
                    let dominantParty = firstLocation.winning_party;
                    let maxCount = 0;
                    
                    Object.entries(partyCount).forEach(([party, count]) => {
                        if (count > maxCount) {
                            maxCount = count;
                            dominantParty = party;
                        }
                    });
                    
                    // Set marker size based on scaling preference
                    const minSize = 5;
                    const maxSize = 20;
                    let radius;
                    
                    if (scalePointsByVotes) {
                        // Scale radius based on votes, but ensure it's visible
                        radius = Math.sqrt(totalVotes) / 10 + 7;
                        // Apply min/max constraints
                        radius = Math.max(minSize, Math.min(radius, maxSize));
                    } else {
                        // Use fixed size if not scaling
                        radius = 8; // Medium-sized fixed radius
                    }
                    
                    // Calculate color intensity based on vote share
                    // Get the winning party's vote share
                    const winningPartyData = locations.find(loc => loc.winning_party === dominantParty);
                    let voteShare = 0;
                    
                    // Debug vote share calculation
                    if (locations[0] && locations[0].name && locations[0].name.includes("Taipei")) {
                        console.log("Vote share debug for:", locations[0].name);
                        console.log("Winning party:", dominantParty);
                        console.log("Locations:", locations);
                    }
                    
                    // Try multiple ways to get the vote share
                    if (winningPartyData && winningPartyData.winning_share) {
                        voteShare = winningPartyData.winning_share;
                    } else if (winningPartyData && winningPartyData.parties && winningPartyData.parties.length > 0) {
                        // Find the winning party in the parties array
                        const party = winningPartyData.parties.find(p => p.name === dominantParty);
                        if (party && party.vote_share) {
                            voteShare = party.vote_share;
                        } else if (party && party.votes && winningPartyData.total_votes) {
                            // Calculate directly if we have votes and total_votes
                            voteShare = (party.votes / winningPartyData.total_votes) * 100;
                        }
                    }
                    
                    // For testing - log points with significant vote share
                    if (voteShare > 70) {
                        console.log(`High vote share point: ${voteShare.toFixed(1)}% for ${dominantParty} at ${locations[0].name}`);
                    } else if (voteShare < 35 && voteShare > 0) {
                        console.log(`Low vote share point: ${voteShare.toFixed(1)}% for ${dominantParty} at ${locations[0].name}`);
                    }
                    
                    // Convert voteShare to a number to ensure proper math operations
                    const numericVoteShare = parseFloat(voteShare);
                    
                    // Set opacity based on user preference
                    let fillOpacity;
                    if (useSolidPoints) {
                        // Use full opacity when solid points are selected
                        fillOpacity = 1.0;
                    } else {
                        // Use semi-transparent points when not solid
                        fillOpacity = 0.5;
                    }
                    
                    // Calculate color based on vote share 
                    // We'll darken/lighten the base party color based on vote share
                    let markerColor = partyColors[dominantParty] || '#666';
                    
                    if (numericVoteShare > 0) {
                        // Get the base color for the party
                        const baseColor = partyColors[dominantParty] || '#999';
                        
                        // Convert to RGB to adjust brightness
                        const rgb = hexToRgb(baseColor);
                        if (rgb) {
                            // Cap vote share at 100% for calculation purposes
                            const cappedShare = Math.min(numericVoteShare, 100);
                            
                            // Low vote share (30%) = lighter (mix with white)
                            // High vote share (70%+) = darker/more saturated
                            
                            // Calculate brightness factor with more pronounced effect
                            // For low vote share (30%), factor is around 1.4 (much lighter)
                            // For high vote share (70%+), factor is around 0.3 (much darker)
                            // Make color intensity variation more dramatic - ranges from 0.4 to 1.4
                            const voteShareFactor = cappedShare / 100;
                            let brightnessFactor;
                            
                            if (voteShareFactor < 0.5) {
                                // For low vote shares, use a different formula to make them lighter
                                brightnessFactor = 1.4 - voteShareFactor;
                            } else {
                                // For high vote shares, make them progressively darker
                                brightnessFactor = 0.9 - (voteShareFactor - 0.5) * 1.0;
                            }
                            
                            // Adjust RGB values based on brightness factor
                            // Use Math.min to ensure we don't go above 255
                            const adjustedR = Math.min(255, Math.floor(rgb.r * brightnessFactor));
                            const adjustedG = Math.min(255, Math.floor(rgb.g * brightnessFactor));
                            const adjustedB = Math.min(255, Math.floor(rgb.b * brightnessFactor));
                            
                            // Convert back to hex
                            markerColor = rgbToHex(adjustedR, adjustedG, adjustedB);
                        }
                    }
                    
                    // Helper function to convert hex to RGB
                    function hexToRgb(hex) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                        
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                    }
                    
                    // Helper function to convert RGB to hex
                    function rgbToHex(r, g, b) {
                        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    }
                    
                    // Helper function to normalize vote share between min and max
                    function normalizeVoteShare(voteShare, min, max) {
                        if (max === min) return 0.5; // If all values are the same, use mid-point
                        return (voteShare - min) / (max - min);
                    }
                    
                    // Diagnostic log for color
                    console.log(`Point for ${locations[0]?.name || "unknown"}: voteShare=${numericVoteShare.toFixed(1)}%, normalized=${normalizeVoteShare(numericVoteShare, minVoteShare, maxVoteShare).toFixed(2)}, color=${markerColor}`);
                    
                    // Create circle marker with improved visibility
                    const marker = L.circleMarker(
                        [parseFloat(latitude), parseFloat(longitude)], 
                        {
                            radius: radius,
                            fillColor: markerColor,
                            color: '#000', // Darker outline for better contrast
                            weight: 1.5,   // Thicker border
                            opacity: 1,
                            fillOpacity: fillOpacity, // Fixed opacity
                            pane: 'markerPane',
                            className: `party-${dominantParty.replace(/\s+/g, '_')}`
                        }
                    );
                    
                    // Add popup with results for all locations at this coordinate
                    marker.bindPopup(createPopupContent(locations));
                    
                    // Add to layer
                    markersLayer.addLayer(marker);
                }
                
                // Handle polygon geometries
                locations.forEach(location => {
                    // Skip if the winning party is not visible
                    if (visibleParties.size > 0 && !visibleParties.has(location.winning_party)) {
                        return;
                    }
                    
                    // Check for any available geometry representation
                    if ((location.geometry || location.geometry_wkt || location.geometry_json) && location.geometry_type) {
                        try {
                            let geoJson = null;
                            
                            // First try GeoJSON if available (highest fidelity)
                            if (location.geometry_json) {
                                console.log(`Using pre-parsed GeoJSON for ${location.name}`);
                                // If already in GeoJSON format, use directly
                                if (location.geometry_json.type && 
                                   (location.geometry_json.type === 'Feature' || 
                                    location.geometry_json.type === 'FeatureCollection' || 
                                    location.geometry_json.type === 'Polygon' || 
                                    location.geometry_json.type === 'MultiPolygon')) {
                                    geoJson = location.geometry_json;
                                } 
                                // If just the geometry part, wrap in a Feature
                                else if (location.geometry_json.coordinates) {
                                    geoJson = {
                                        type: 'Feature',
                                        properties: {},
                                        geometry: location.geometry_json
                                    };
                                }
                            }
                            
                            // If no GeoJSON, try WKT next
                            if (!geoJson && location.geometry_wkt) {
                                console.log(`Attempting to parse WKT for ${location.name}:`, 
                                    typeof location.geometry_wkt === 'string' ? 
                                    location.geometry_wkt.substring(0, 50) + '...' : 
                                    '[not a string]');
                                
                                geoJson = parseGeometry(location.geometry_wkt, location);
                            }
                            
                            // Finally fall back to raw geometry object
                            if (!geoJson) {
                                console.log(`Attempting to parse raw geometry for ${location.name}:`, 
                                    typeof location.geometry === 'object' ? 
                                    'Object with keys: ' + Object.keys(location.geometry).join(', ') : 
                                    typeof location.geometry);
                                
                                geoJson = parseGeometry(location.geometry, location);
                            }
                            
                            if (geoJson) {
                                hasPolygons = true;
                                console.log("Successfully parsed geometry:", location.name);
                                
                                // Determine the coordinate system/SRID
                                let srid = 4326; // Default to WGS84 (lat/lng)
                                
                                // Check if we have SRID information available
                                if (location.geometry_srid) {
                                    srid = parseInt(location.geometry_srid);
                                    console.log(`Using SRID ${srid} for geometry conversion`);
                                } 
                                // Try to infer it from coordinate values
                                else {
                                    // Check a sample coordinate to guess SRID
                                    let sampleCoords = null;
                                    
                                    if (geoJson.geometry && geoJson.geometry.coordinates) {
                                        if (Array.isArray(geoJson.geometry.coordinates[0])) {
                                            if (Array.isArray(geoJson.geometry.coordinates[0][0])) {
                                                sampleCoords = geoJson.geometry.coordinates[0][0];
                                            } else {
                                                sampleCoords = geoJson.geometry.coordinates[0];
                                            }
                                        } else {
                                            sampleCoords = geoJson.geometry.coordinates;
                                        }
                                    }
                                    
                                    if (sampleCoords && sampleCoords.length >= 2) {
                                        const x = Math.abs(sampleCoords[0]);
                                        const y = Math.abs(sampleCoords[1]);
                                        
                                        // If coordinates are very large, likely EPSG:3857 (Web Mercator)
                                        if (x > 1000000 || y > 1000000) {
                                            srid = 3857;
                                            console.log("Detected likely Web Mercator coordinates (EPSG:3857)");
                                        }
                                        // If coordinates are between 0-180, likely WGS84
                                        else if (x <= 180 && y <= 90) {
                                            srid = 4326;
                                            console.log("Detected likely WGS84 coordinates (EPSG:4326)");
                                        }
                                        // For values outside those ranges but not huge, could be local coordinate system 
                                        else {
                                            console.log("Unknown coordinate system, using best guess");
                                            // Check if coordinates look like they're in the Albania region (rough check)
                                            const inAlbaniaRegion = (x >= 19 && x <= 21 && y >= 39 && y <= 43);
                                            srid = inAlbaniaRegion ? 4326 : 3857;
                                        }
                                    }
                                }
                                
                                const polygon = L.geoJSON(geoJson, {
                                    coordsToLatLng: function(coords) {
                                        try {
                                            const x = parseFloat(coords[0]);
                                            const y = parseFloat(coords[1]);
                                            
                                            // Different coordinate transformations based on SRID
                                            if (srid === 4326) {
                                                // WGS84 - standard lat/lng, but note axis order 
                                                // Usually it's [longitude, latitude] in GeoJSON
                                                return new L.LatLng(y, x);
                                            } 
                                            else if (srid === 3857) {
                                                // Web Mercator - needs conversion to lat/lng
                                                const { lat, lng } = mercatorToLatLng(x, y);
                                                
                                                // Sanity check
                                                if (isNaN(lat) || isNaN(lng) || 
                                                    Math.abs(lat) > 90 || Math.abs(lng) > 180) {
                                                    console.error("Invalid coordinate conversion:", x, y, "->", lat, lng);
                                                    return new L.LatLng(41.3275, 19.8187); // Albania center
                                                }
                                                
                                                return new L.LatLng(lat, lng);
                                            }
                                            else {
                                                // Unknown SRID, make a guess based on coordinate values
                                                if (Math.abs(x) < 180 && Math.abs(y) < 90) {
                                                    // Looks like WGS84
                                                    return new L.LatLng(y, x);
                                                } else {
                                                    // Try a Web Mercator conversion as fallback
                                                    const { lat, lng } = mercatorToLatLng(x, y);
                                                    if (!isNaN(lat) && !isNaN(lng) && 
                                                        Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                                                        return new L.LatLng(lat, lng);
                                                    }
                                                }
                                                
                                                // Last resort fallback to Albania center
                                                console.error("Could not convert coordinates:", x, y);
                                                return new L.LatLng(41.3275, 19.8187);
                                            }
                                        } catch (e) {
                                            console.error("Error in coordinate conversion:", e);
                                            return new L.LatLng(41.3275, 19.8187); // Albania center
                                        }
                                    },
                                    style: function() {
                                        return {
                                            fillColor: partyColors[location.winning_party] || '#999',
                                            weight: 1.5,
                                            opacity: 1,
                                            color: '#333',
                                            fillOpacity: 0.7
                                        };
                                    },
                                    className: `party-${location.winning_party.replace(/\s+/g, '_')}`
                                });
                                
                                // Add popup with results
                                polygon.bindPopup(createPopupContent([location]));
                                
                                // Add to layer
                                polygonsLayer.addLayer(polygon);
                            } else {
                                console.log("Failed to parse geometry (returned null):", location.name);
                            }
                        } catch (e) {
                            console.error('Error parsing geometry for', location.name, e);
                            // Log the problematic geometry string
                            if (location.geometry) {
                                console.error('Geometry string that caused error:', 
                                    typeof location.geometry,
                                    typeof location.geometry === 'string' ? location.geometry.substring(0, 100) : '[not a string]');
                            }
                        }
                    }
                });
            });
            
            // If no polygons are available and the display mode is 'polygons', show a warning
            if (!hasPolygons && displayMode === 'polygons') {
                showError('No polygon data available. Showing points instead.');
                displayModeSelect.value = 'points';
                displayMode = 'points';
            }
        }
        
        // Parse geometry for EPSG:3857 projection (can handle string WKT or binary data)
        function parseGeometry(geometry, currentLocation) {
            if (!geometry) return null;
            
            try {
                // Instead of trying to parse the binary geometry, let's try to use the 
                // standard geometry format that should be available
                if (typeof geometry === 'object') {
                    // IMPORTANT: We need to use the actual database geometry
                    // Let's try several approaches
                    
                    console.log("Inspecting binary geometry object:", Object.keys(geometry).join(', '));
                    
                    // Try method 1: If the geometry has a toGeoJSON method (common in some libraries)
                    if (geometry.toGeoJSON && typeof geometry.toGeoJSON === 'function') {
                        try {
                            const geoJson = geometry.toGeoJSON();
                            console.log("Successfully converted geometry using toGeoJSON method");
                            return geoJson;
                        } catch (e) {
                            console.error("Error converting with toGeoJSON:", e);
                        }
                    }
                    
                    // Try method 2: If the geometry has a toString or toWKT method
                    if (geometry.toString && typeof geometry.toString === 'function') {
                        try {
                            const wktStr = geometry.toString();
                            if (typeof wktStr === 'string' && 
                                ((wktStr.toUpperCase && wktStr.toUpperCase().includes('POLYGON')) || 
                                 (wktStr.toUpperCase && wktStr.toUpperCase().includes('POINT')) || 
                                 (wktStr.toUpperCase && wktStr.toUpperCase().includes('LINESTRING')))) {
                                console.log("Found WKT from toString:", 
                                    wktStr.substring ? wktStr.substring(0, 50) + "..." : wktStr);
                                // Try to parse this as WKT later in the function
                                return parseGeometry(wktStr, currentLocation);
                            }
                        } catch (e) {
                            console.error("Error with toString method:", e);
                        }
                    }
                    
                    if (geometry.toWKT && typeof geometry.toWKT === 'function') {
                        try {
                            const wktStr = geometry.toWKT();
                            console.log("Found WKT from toWKT:", 
                                typeof wktStr === 'string' && wktStr.substring ? 
                                wktStr.substring(0, 50) + "..." : typeof wktStr);
                            return parseGeometry(wktStr, currentLocation);
                        } catch (e) {
                            console.error("Error with toWKT method:", e);
                        }
                    }
                    
                    // Try method 3: If the geometry has coordinates or rings properties directly
                    if (geometry.coordinates || (geometry.rings && Array.isArray(geometry.rings))) {
                        try {
                            const coords = geometry.coordinates || geometry.rings;
                            if (Array.isArray(coords) && coords.length > 0) {
                                // Determine geometry type
                                let geomType = 'Polygon';
                                if (geometry.type) {
                                    geomType = geometry.type;
                                } else if (geometry.geometryType) {
                                    geomType = geometry.geometryType;
                                } else if (Array.isArray(coords[0]) && !Array.isArray(coords[0][0])) {
                                    geomType = 'LineString';
                                } else if (Array.isArray(coords[0]) && Array.isArray(coords[0][0]) && Array.isArray(coords[0][0][0])) {
                                    geomType = 'MultiPolygon';
                                }
                                
                                console.log(`Found direct coordinates, creating ${geomType}`);
                                return {
                                    type: 'Feature',
                                    properties: {},
                                    geometry: {
                                        type: geomType,
                                        coordinates: coords
                                    }
                                };
                            }
                        } catch (e) {
                            console.error("Error extracting direct coordinates:", e);
                        }
                    }
                    
                    // Try method 4: Look for any properties that might contain the data
                    for (const key of Object.keys(geometry)) {
                        // Skip common non-geometry properties
                        if (['id', 'type', 'properties', 'crs'].includes(key)) continue;
                        
                        try {
                            const value = geometry[key];
                            
                            // If the value is a string and looks like WKT
                            if (typeof value === 'string' && value.toUpperCase && 
                               (value.toUpperCase().includes('POLYGON') || 
                                value.toUpperCase().includes('POINT') || 
                                value.toUpperCase().includes('LINESTRING'))) {
                                console.log(`Found potential WKT in property ${key}:`, 
                                    value.substring ? value.substring(0, 50) + "..." : value);
                                return parseGeometry(value, currentLocation);
                            }
                            
                            // If it's an array that might be coordinates
                            if (Array.isArray(value) && value.length > 0) {
                                // Check if it has coordinate-like structure
                                const isCoordinates = Array.isArray(value[0]) && 
                                                    value[0].length >= 2 && 
                                                    typeof value[0][0] === 'number';
                                
                                if (isCoordinates) {
                                    console.log(`Found potential coordinates in property ${key}`);
                                    
                                    // Determine if it's a LineString or Polygon
                                    let geomType = 'Polygon';
                                    if (!Array.isArray(value[0][0])) {
                                        geomType = 'LineString';
                                    } else if (Array.isArray(value[0][0]) && Array.isArray(value[0][0][0])) {
                                        geomType = 'MultiPolygon';
                                    }
                                    
                                    return {
                                        type: 'Feature',
                                        properties: {},
                                        geometry: {
                                            type: geomType,
                                            coordinates: value
                                        }
                                    };
                                }
                            }
                        } catch (e) {
                            console.error(`Error examining property ${key}:`, e);
                        }
                    }
                    
                    // Try method 5: Try to interpret binary data if present
                    if (geometry.bytes && Array.isArray(geometry.bytes)) {
                        // We could implement a full WKB parser here, but for simplicity
                        // we'll leave this as a placeholder
                        console.log("Binary geometry data found but proper WKB parsing is not implemented");
                    }
                    
                    // If we have geometry_type, try to create a sensible default
                    if (currentLocation && currentLocation.geometry_type) {
                        console.log(`Creating default geometry based on type: ${currentLocation.geometry_type}`);
                        
                        if (currentLocation.latitude && currentLocation.longitude) {
                            const { mercatorX, mercatorY } = latLngToMercator(
                                currentLocation.latitude, 
                                currentLocation.longitude
                            );
                            
                            if (currentLocation.geometry_type.toUpperCase().includes('POINT')) {
                                return {
                                    type: 'Feature',
                                    properties: {},
                                    geometry: {
                                        type: 'Point',
                                        coordinates: [mercatorX, mercatorY]
                                    }
                                };
                            } else {
                                // For all other types, create a circle
                                const points = 32; // More points for smoother circle
                                const radius = 2000; // meters
                                const coordinates = [];
                                
                                for (let i = 0; i <= points; i++) {
                                    const angle = (Math.PI * 2 * i) / points;
                                    coordinates.push([
                                        mercatorX + radius * Math.cos(angle),
                                        mercatorY + radius * Math.sin(angle)
                                    ]);
                                }
                                
                                return {
                                    type: 'Feature',
                                    properties: {},
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [coordinates]
                                    }
                                };
                            }
                        }
                    }
                    
                    console.log("URGENT NOTICE: Cannot parse geometry object for", 
                                currentLocation ? currentLocation.name : "unknown location", 
                                "- please check database format and ensure proper geometry conversion");
                    
                    // CRITICAL: As a last resort, log the full geometry object for debugging
                    // This helps identify the exact format for future parsing
                    try {
                        console.log("Full geometry object:", JSON.stringify(geometry));
                    } catch (e) {
                        console.log("Geometry cannot be stringified:", e);
                        console.log("Raw geometry keys:", Object.keys(geometry));
                        
                        // Try logging each property separately
                        for (const key of Object.keys(geometry)) {
                            try {
                                console.log(`Property ${key}:`, geometry[key]);
                            } catch (err) {
                                console.log(`Property ${key} cannot be logged:`, err);
                            }
                        }
                    }
                    
                    return null;
                }
                
                // String-based WKT parsing
                const geometryStr = geometry;
                // Log geometry string for debugging
                console.log("Parsing string geometry:", 
                    typeof geometryStr === 'string' && geometryStr.substring ? 
                    geometryStr.substring(0, 100) : typeof geometryStr);
                
                // Handle "GEOMETRYCOLLECTION EMPTY" case
                if (typeof geometryStr === 'string' && 
                    (geometryStr === "GEOMETRYCOLLECTION EMPTY" || 
                     (geometryStr.includes && geometryStr.includes("EMPTY")))) {
                    return null;
                }
                
                // Try to identify geometry format (WKT or other)
                if (typeof geometryStr !== 'string') {
                    console.log("Geometry is not a string or object:", typeof geometryStr);
                    return null;
                }
                
                // Convert potential JSON string to object
                if (geometryStr.trim().startsWith('{') || geometryStr.trim().startsWith('[')) {
                    try {
                        const geoJson = JSON.parse(geometryStr);
                        // If we have a valid GeoJSON, return it directly
                        if (geoJson && 
                            (geoJson.type === 'Feature' || 
                             geoJson.type === 'FeatureCollection' || 
                             geoJson.type === 'Polygon' || 
                             geoJson.type === 'MultiPolygon')) {
                            return geoJson;
                        }
                    } catch (e) {
                        console.log("Not valid JSON:", e.message);
                    }
                }
                
                // Improved Well-Known Text (WKT) parser
                try {
                    console.log("Attempting to parse WKT format");
                    
                    // Function to parse WKT coordinate sequence
                    function parseCoordinateSequence(seqStr) {
                        // Split by commas, and parse each coordinate pair
                        return seqStr.split(/,\s*/).map(pairStr => {
                            // Split coordinate pair by whitespace
                            const pair = pairStr.trim().split(/\s+/);
                            if (pair.length >= 2) {
                                return [parseFloat(pair[0]), parseFloat(pair[1])];
                            }
                            return null;
                        }).filter(Boolean);
                    }
                    
                    // Handle different WKT geometry types
                    const wktStr = geometryStr.trim();
                    
                    // POINT(x y)
                    if (wktStr.toUpperCase().startsWith('POINT')) {
                        const match = wktStr.match(/POINT\s*\(([^)]+)\)/i);
                        if (match && match[1]) {
                            const coords = match[1].trim().split(/\s+/).map(parseFloat);
                            if (coords.length >= 2) {
                                return {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: [coords[0], coords[1]]
                                    },
                                    properties: {}
                                };
                            }
                        }
                    }
                    
                    // LINESTRING(x1 y1, x2 y2, ...)
                    else if (wktStr.toUpperCase().startsWith('LINESTRING')) {
                        const match = wktStr.match(/LINESTRING\s*\(\s*(.*?)\s*\)/i);
                        if (match && match[1]) {
                            const coordinates = parseCoordinateSequence(match[1]);
                            if (coordinates.length >= 2) {
                                return {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: coordinates
                                    },
                                    properties: {}
                                };
                            }
                        }
                    }
                    
                    // POLYGON((x1 y1, x2 y2, ...), (inner1), (inner2), ...)
                    else if (wktStr.toUpperCase().startsWith('POLYGON')) {
                        // This regex matches all coordinate rings in the polygon
                        const ringsMatches = wktStr.match(/POLYGON\s*\(\s*(.*)\s*\)/i);
                        
                        if (ringsMatches && ringsMatches[1]) {
                            // Extract all rings by matching content between parentheses
                            const allRingsStr = ringsMatches[1];
                            const ringMatches = allRingsStr.match(/\(\s*(.*?)\s*\)/g);
                            
                            if (ringMatches && ringMatches.length > 0) {
                                // Parse each ring's coordinates
                                const rings = ringMatches.map(ringStr => {
                                    // Remove outer parentheses and parse coordinates
                                    const coordsStr = ringStr.slice(1, -1);
                                    return parseCoordinateSequence(coordsStr);
                                }).filter(ring => ring.length >= 3);
                                
                                // Ensure all rings are closed
                                rings.forEach(ring => {
                                    if (ring[0][0] !== ring[ring.length - 1][0] || 
                                        ring[0][1] !== ring[ring.length - 1][1]) {
                                        ring.push([ring[0][0], ring[0][1]]);
                                    }
                                });
                                
                                if (rings.length > 0) {
                                    return {
                                        type: 'Feature',
                                        geometry: {
                                            type: 'Polygon',
                                            coordinates: rings
                                        },
                                        properties: {}
                                    };
                                }
                            }
                        }
                    }
                    
                    // MULTIPOLYGON(((x1 y1, ...)), ((x2 y2, ...)), ...)
                    else if (wktStr.toUpperCase().startsWith('MULTIPOLYGON')) {
                        const match = wktStr.match(/MULTIPOLYGON\s*\(\s*(.*)\s*\)/i);
                        
                        if (match && match[1]) {
                            // Extract each polygon
                            let polygons = [];
                            let depth = 0;
                            let currentPolygon = '';
                            
                            // Simpler approach using regex to extract polygons
                            const polygonMatches = match[1].match(/\(\s*\(\s*.*?\s*\)\s*\)/g);
                            
                            if (polygonMatches) {
                                polygons = polygonMatches.map(polyStr => {
                                    // Remove outer parentheses: ((..)) -> (..)
                                    const ringMatches = polyStr.match(/\(\s*(.*?)\s*\)/g);
                                    
                                    if (ringMatches) {
                                        return ringMatches.map(ringStr => {
                                            // Remove outer parentheses and parse
                                            const coordsStr = ringStr.slice(1, -1);
                                            return parseCoordinateSequence(coordsStr);
                                        }).filter(ring => ring.length >= 3);
                                    }
                                    return [];
                                }).filter(poly => poly.length > 0);
                                
                                // Ensure all rings are closed
                                polygons.forEach(poly => {
                                    poly.forEach(ring => {
                                        if (ring[0][0] !== ring[ring.length - 1][0] || 
                                            ring[0][1] !== ring[ring.length - 1][1]) {
                                            ring.push([ring[0][0], ring[0][1]]);
                                        }
                                    });
                                });
                                
                                if (polygons.length > 0) {
                                    return {
                                        type: 'Feature',
                                        geometry: {
                                            type: 'MultiPolygon',
                                            coordinates: polygons
                                        },
                                        properties: {}
                                    };
                                }
                            }
                        }
                    }
                    
                    // If we get here, use a more basic approach
                    // Check for WKT Polygon format: POLYGON((x1 y1, x2 y2, ...))
                    if (wktStr.toUpperCase().includes("POLYGON")) {
                        let polyMatch = wktStr.match(/POLYGON\s*\(\((.*?)\)\)/i);
                        
                        // Try different regex if the first one doesn't match
                        if (!polyMatch) {
                            polyMatch = wktStr.match(/POLYGON\s*\(\(([\s\S]*?)\)\)/i);
                        }
                        
                        if (polyMatch && polyMatch[1]) {
                            const coordStr = polyMatch[1];
                            const coordinates = coordStr.split(/,\s*/).map(pair => {
                                const coords = pair.trim().split(/\s+/).map(Number);
                                return coords.length >= 2 ? [coords[0], coords[1]] : null;
                            }).filter(Boolean);
                            
                            if (coordinates.length >= 3) {
                                // Ensure the polygon is closed
                                if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] ||
                                    coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
                                    coordinates.push([coordinates[0][0], coordinates[0][1]]);
                                }
                                
                                return {
                                    type: 'Feature',
                                    properties: {},
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [coordinates]
                                    }
                                };
                            }
                        }
                    }
                    
                    console.log("Failed to parse WKT geometry: " + wktStr.substring(0, 100));
                    
                    // If we still can't parse it, check if it looks like coordinate pairs
                    if (wktStr.includes(',') && wktStr.includes(' ')) {
                        // Try to extract any coordinate-looking pairs
                        const potentialCoords = wktStr.match(/[-\d.]+\s+[-\d.]+/g);
                        if (potentialCoords && potentialCoords.length >= 3) {
                            const coordinates = potentialCoords.map(pair => {
                                const coords = pair.trim().split(/\s+/).map(Number);
                                return coords.length === 2 ? coords : null;
                            }).filter(Boolean);
                            
                            if (coordinates.length >= 3) {
                                // Ensure the polygon is closed
                                if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] ||
                                    coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
                                    coordinates.push([coordinates[0][0], coordinates[0][1]]);
                                }
                                
                                console.log(`Extracted ${coordinates.length} coordinates as fallback`);
                                
                                return {
                                    type: 'Feature',
                                    properties: {},
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [coordinates]
                                    }
                                };
                            }
                        }
                    }
                    
                } catch (e) {
                    console.error("Error in WKT parsing:", e);
                }
                
                console.log("Could not parse geometry, falling back to point-based representation");
                
                // If we can't parse the geometry but have location coordinates, create a circle
                if (currentLocation && currentLocation.latitude && currentLocation.longitude) {
                    const { mercatorX, mercatorY } = latLngToMercator(
                        currentLocation.latitude, 
                        currentLocation.longitude
                    );
                    
                    // Create a circle (approximated by a 20-sided polygon)
                    const points = 20;
                    const radius = 2000; // meters
                    const coordinates = [];
                    
                    for (let i = 0; i <= points; i++) {
                        const angle = (Math.PI * 2 * i) / points;
                        coordinates.push([
                            mercatorX + radius * Math.cos(angle),
                            mercatorY + radius * Math.sin(angle)
                        ]);
                    }
                    
                    console.log("Created fallback circle geometry");
                    
                    return {
                        type: 'Feature',
                        properties: {},
                        geometry: {
                            type: 'Polygon',
                            coordinates: [coordinates]
                        }
                    };
                }
                
                // If all parsing methods fail
                return null;
            } catch (e) {
                console.error('Failed to parse geometry:', e);
                console.error('Geometry string that failed:', geometryStr);
                return null;
            }
        }
        
        // Create popup content
        function createPopupContent(locations) {
            const content = document.createElement('div');
            content.className = 'popup-content';
            
            // If there's only one location, just show its details
            if (locations.length === 1) {
                const location = locations[0];
                
                // Show nested hierarchy of names
                const title = document.createElement('h3');
                title.textContent = location.name;
                content.appendChild(title);
                
                // Show detailed hierarchy if available
                if (location.fullDetails) {
                    const hierarchy = document.createElement('p');
                    hierarchy.style.fontSize = '12px';
                    hierarchy.style.fontStyle = 'italic';
                    hierarchy.style.marginTop = '-8px';
                    
                    // Get the labels for each level based on data structure
                    // This is a generic approach that will work with any number of NAME columns
                    const nameLabels = {
                        NAME1: 'Level 1',
                        NAME2: 'Level 2',
                        NAME3: 'Level 3',
                        NAME4: 'Level 4',
                        NAME5: 'Level 5',
                        NAME6: 'Level 6'
                        // Add more if needed
                    };
                    
                        // Simply use the column name itself as the label
                    // This will make display like "NAME1", "NAME2", etc.
                    
                    // When we have suffixed columns, we'll show them directly too 
                    const suffixes = ['_b', '_c', '_d', '_e', '_f', '_g', '_h'];
                    
                    // Generate labels for possible suffixed columns
                    for (let i = 1; i <= 10; i++) {
                        // Base name columns
                        const upperBase = `NAME${i}`;
                        const lowerBase = `name${i}`;
                        
                        // Keep original column name as label
                        nameLabels[upperBase] = upperBase;
                        nameLabels[lowerBase] = lowerBase;
                        
                        // Add suffixed versions
                        suffixes.forEach(suffix => {
                            const upperSuffixed = `${upperBase}${suffix}`;
                            const lowerSuffixed = `${lowerBase}${suffix}`;
                            
                            nameLabels[upperSuffixed] = upperSuffixed;
                            nameLabels[lowerSuffixed] = lowerSuffixed;
                        });
                    }
                    
                    const hierarchyItems = [];
                    
                    // Loop through all available NAME columns
                    if (location.nameColumns) {
                        location.nameColumns.forEach(col => {
                            if (location.fullDetails[col]) {
                                hierarchyItems.push(`<strong>${nameLabels[col] || col}:</strong> ${location.fullDetails[col]}`);
                            }
                        });
                    } else {
                        // Fallback for older data format
                        for (let i = 1; i <= 10; i++) {
                            const nameCol = `NAME${i}`;
                            if (location.fullDetails[nameCol]) {
                                hierarchyItems.push(`<strong>${nameLabels[nameCol] || nameCol}:</strong> ${location.fullDetails[nameCol]}`);
                            }
                        }
                    }
                    
                    hierarchy.innerHTML = hierarchyItems.join('<br>');
                    content.appendChild(hierarchy);
                }
                
                const info = document.createElement('p');
                
                // Start with total votes which should always be present
                let infoHTML = `<strong>Total Votes:</strong> ${location.total_votes}<br>`;
                
                // Add registered voters if available (could be 'reg' or 'evp')
                if (location.reg !== undefined) {
                    // Use better labels depending on the field
                    let fieldName = 'Registered Voters';
                    if (location.regField === 'evp' || location.regField === 'EVP') {
                        fieldName = 'Eligible Voters';
                    }
                    infoHTML += `<strong>${fieldName}:</strong> ${location.reg}<br>`;
                }
                
                // Add turnout if available
                if (location.turnout !== undefined) {
                    // Always just display as Turnout
                    infoHTML += `<strong>Turnout:</strong> ${(location.turnout * 100).toFixed(1)}%<br>`;
                } else if (location.turnout_reg !== undefined) {
                    // Fallback for backward compatibility
                    infoHTML += `<strong>Turnout:</strong> ${(location.turnout_reg * 100).toFixed(1)}%<br>`;
                }
                
                // Add geocoding source if available - only use geometry_type_b
                if (location.geometry_type_b) {
                    infoHTML += `<strong>Geocoding Source:</strong> ${location.geometry_type_b}<br>`;
                    // Debug the geometry_type_b field
                    console.log("Popup content - geometry_type_b:", location.geometry_type_b);
                } else {
                    console.log("No geometry_type_b found for location:", location.name);
                }
                
                info.innerHTML = infoHTML;
                content.appendChild(info);
                
                // Create a scrollable container for the table
                const tableContainer = document.createElement('div');
                tableContainer.style.maxHeight = '200px';
                tableContainer.style.overflowY = 'auto';
                tableContainer.style.marginTop = '10px';
                
                // Limit to top 10 parties and sort by votes
                const topParties = [...location.parties]
                    .sort((a, b) => b.votes - a.votes)
                    .slice(0, 10);
                
                const table = document.createElement('table');
                table.style.width = '100%';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Party</th>
                            <th>Votes</th>
                            <th>Share</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topParties.map(party => {
                            // Always show party name 
                            let partyDisplay = party.name;
                            
                            // Collect all variants of the party name that differ from the main name
                            const variants = [];
                            
                            // Add all party field variants dynamically by checking party object
                            for (const [key, value] of Object.entries(party)) {
                                // Skip non-string values and the main party name field
                                if (typeof value !== 'string' || 
                                    key === 'name' || 
                                    value === party.name ||
                                    key === 'votes' ||
                                    key === 'vote_share') {
                                    continue;
                                }
                                
                                // Add this variant to our list
                                if (value && value.trim() !== '') {
                                    variants.push(value);
                                }
                            }
                            
                            // Create HTML for the variants in small text
                            let variantsHTML = '';
                            if (variants.length > 0) {
                                variantsHTML = `<div style="font-size:10px; color:#666;">${variants.join('<br>')}</div>`;
                            }
                            
                            return `
                            <tr style="color: ${partyColors[party.name] || '#000'}">
                                <td>${partyDisplay}${variantsHTML}</td>
                                <td>${party.votes}</td>
                                <td>${party.vote_share.toFixed(1)}%</td>
                            </tr>
                            `;
                        }).join('')}
                    </tbody>
                `;
                
                // Add party count info if there are more parties
                if (location.parties.length > 10) {
                    const morePartiesInfo = document.createElement('p');
                    morePartiesInfo.style.fontSize = '12px';
                    morePartiesInfo.style.fontStyle = 'italic';
                    morePartiesInfo.style.textAlign = 'right';
                    morePartiesInfo.textContent = `+ ${location.parties.length - 10} more parties`;
                    tableContainer.appendChild(table);
                    tableContainer.appendChild(morePartiesInfo);
                } else {
                    tableContainer.appendChild(table);
                }
                
                content.appendChild(tableContainer);
            } 
            // For multiple locations, show a selector and individual results
            else {
                const title = document.createElement('h3');
                title.textContent = `${locations.length} Locations at this Coordinate`;
                content.appendChild(title);
                
                // Create location selector
                const selectorDiv = document.createElement('div');
                selectorDiv.style.marginBottom = '10px';
                
                const locationSelect = document.createElement('select');
                locationSelect.style.width = '100%';
                locationSelect.style.marginBottom = '10px';
                
                locations.forEach((location, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = location.name;
                    locationSelect.appendChild(option);
                });
                
                selectorDiv.appendChild(locationSelect);
                content.appendChild(selectorDiv);
                
                // Container for location details that will be updated on selection change
                const locationDetailsDiv = document.createElement('div');
                content.appendChild(locationDetailsDiv);
                
                // Function to update displayed location details
                const updateLocationDetails = (index) => {
                    const selectedLocation = locations[index];
                    
                    let hierarchyHTML = '';
                    if (selectedLocation.fullDetails) {
                        // Get the labels for each level based on data structure
                        const nameLabels = {
                            NAME1: 'Level 1',
                            NAME2: 'Level 2',
                            NAME3: 'Level 3',
                            NAME4: 'Level 4',
                            NAME5: 'Level 5',
                            NAME6: 'Level 6',
                            // Also add lowercase versions
                            name1: 'Level 1',
                            name2: 'Level 2',
                            name3: 'Level 3',
                            name4: 'Level 4',
                            name5: 'Level 5',
                            name6: 'Level 6'
                            // Add more if needed
                        };
                        
                        // Simply use the column name itself as the label
                        // This will make display like "NAME1", "NAME2", etc.
                        
                        // When we have suffixed columns, we'll show them directly too 
                        const suffixes = ['_b', '_c', '_d', '_e', '_f', '_g', '_h'];
                        
                        // Generate labels for possible suffixed columns
                        for (let i = 1; i <= 10; i++) {
                            // Base name columns
                            const upperBase = `NAME${i}`;
                            const lowerBase = `name${i}`;
                            
                            // Keep original column name as label
                            nameLabels[upperBase] = upperBase;
                            nameLabels[lowerBase] = lowerBase;
                            
                            // Add suffixed versions
                            suffixes.forEach(suffix => {
                                const upperSuffixed = `${upperBase}${suffix}`;
                                const lowerSuffixed = `${lowerBase}${suffix}`;
                                
                                nameLabels[upperSuffixed] = upperSuffixed;
                                nameLabels[lowerSuffixed] = lowerSuffixed;
                            });
                        }
                        
                        const hierarchyItems = [];
                        
                        // Loop through all available NAME columns
                        if (selectedLocation.nameColumns) {
                            selectedLocation.nameColumns.forEach(col => {
                                if (selectedLocation.fullDetails[col]) {
                                    hierarchyItems.push(`<strong>${nameLabels[col] || col}:</strong> ${selectedLocation.fullDetails[col]}`);
                                }
                            });
                        } else {
                            // Fallback for older data format
                            for (let i = 1; i <= 10; i++) {
                                const nameCol = `NAME${i}`;
                                if (selectedLocation.fullDetails[nameCol]) {
                                    hierarchyItems.push(`<strong>${nameLabels[nameCol] || nameCol}:</strong> ${selectedLocation.fullDetails[nameCol]}`);
                                }
                            }
                        }
                        
                        hierarchyHTML = `
                            <p style="font-size: 12px; font-style: italic; margin-top: 5px;">
                                ${hierarchyItems.join('<br>')}
                            </p>
                        `;
                    }
                    
                    // Build the info HTML with total votes and optional reg/turnout
                    let infoHTML = `<strong>Total Votes:</strong> ${selectedLocation.total_votes}<br>`;
                    
                    // Add registered voters if available
                    if (selectedLocation.reg !== undefined) {
                        // Use better labels depending on the field
                        let fieldName = 'Registered Voters';
                        if (selectedLocation.regField === 'evp' || selectedLocation.regField === 'EVP') {
                            fieldName = 'Eligible Voters';
                        }
                        infoHTML += `<strong>${fieldName}:</strong> ${selectedLocation.reg}<br>`;
                    }
                    
                    // Add turnout if available
                    if (selectedLocation.turnout !== undefined) {
                        // Always display as Turnout 
                        infoHTML += `<strong>Turnout:</strong> ${(selectedLocation.turnout * 100).toFixed(1)}%<br>`;
                    } else if (selectedLocation.turnout_reg !== undefined) {
                        // Fallback for backward compatibility
                        infoHTML += `<strong>Turnout:</strong> ${(selectedLocation.turnout_reg * 100).toFixed(1)}%<br>`;
                    }
                    
                    // Add geocoding source if available - only use geometry_type_b
                    if (selectedLocation.geometry_type_b) {
                        infoHTML += `<strong>Geocoding Source:</strong> ${selectedLocation.geometry_type_b}<br>`;
                        // Debug the geometry_type_b field
                        console.log("Popup content (multiple) - geometry_type_b:", selectedLocation.geometry_type_b);
                    } else {
                        console.log("No geometry_type_b found for location (multiple):", selectedLocation.name);
                    }
                    
                    locationDetailsDiv.innerHTML = `
                        ${hierarchyHTML}
                        <p>
                            ${infoHTML}
                        </p>
                        <div style="max-height: 200px; overflow-y: auto; margin-top: 10px;">
                            ${(() => {
                                // Limit to top 10 parties and sort by votes
                                const topParties = [...selectedLocation.parties]
                                    .sort((a, b) => b.votes - a.votes)
                                    .slice(0, 10);
                                
                                let html = `
                                    <table style="width: 100%;">
                                        <thead>
                                            <tr>
                                                <th>Party</th>
                                                <th>Votes</th>
                                                <th>Share</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${topParties.map(party => {
                                                // Always show party name 
                                                let partyDisplay = party.name;
                                                
                                                // Collect all variants of the party name that differ from the main name
                                                const variants = [];
                                                
                                                // Add all party field variants dynamically by checking party object
                                                for (const [key, value] of Object.entries(party)) {
                                                    // Skip non-string values and the main party name field
                                                    if (typeof value !== 'string' || 
                                                        key === 'name' || 
                                                        value === party.name ||
                                                        key === 'votes' ||
                                                        key === 'vote_share') {
                                                        continue;
                                                    }
                                                    
                                                    // Add this variant to our list
                                                    if (value && value.trim() !== '') {
                                                        variants.push(value);
                                                    }
                                                }
                                                
                                                // Create HTML for the variants in small text
                                                let variantsHTML = '';
                                                if (variants.length > 0) {
                                                    variantsHTML = `<div style="font-size:10px; color:#666;">${variants.join('<br>')}</div>`;
                                                }
                                                
                                                return `
                                                <tr style="color: ${partyColors[party.name] || '#000'}">
                                                    <td>${partyDisplay}${variantsHTML}</td>
                                                    <td>${party.votes}</td>
                                                    <td>${party.vote_share.toFixed(1)}%</td>
                                                </tr>
                                                `;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                `;
                                
                                // Add info about more parties if needed
                                if (selectedLocation.parties.length > 10) {
                                    html += `
                                        <p style="font-size: 12px; font-style: italic; text-align: right;">
                                            + ${selectedLocation.parties.length - 10} more parties
                                        </p>
                                    `;
                                }
                                
                                return html;
                            })()}
                        </div>
                    `;
                };
                
                // Initialize with first location
                updateLocationDetails(0);
                
                // Add event listener to update details when selection changes
                locationSelect.addEventListener('change', (e) => {
                    updateLocationDetails(parseInt(e.target.value));
                });
            }
            
            return content;
        }
        
        // Create legend control with vote share and customization options
        function createLegend(parties) {
            // Remove existing legend if any
            if (legendControl) {
                map.removeControl(legendControl);
            }
            
            // Initialize visibleParties with all parties
            visibleParties = new Set(parties);
            
            // Calculate country-wide vote shares for each party
            const partyVoteTotals = {};
            let totalVotes = 0;
            
            // Initialize vote totals for each party
            parties.forEach(party => {
                partyVoteTotals[party] = 0;
            });
            
            // Debug - Check parties in first few locations
            console.log("Checking party vote share data:");
            if (allLocations.length > 0) {
                for (let i = 0; i < Math.min(5, allLocations.length); i++) {
                    const loc = allLocations[i];
                    console.log(`Location ${i} (${loc.name}):`);
                    console.log("- Parties:", loc.parties);
                    if (loc.parties && loc.parties.length > 0) {
                        loc.parties.forEach(party => {
                            console.log(`  - ${party.name}: ${party.votes} votes (${party.vote_share?.toFixed(1) || "N/A"}%)`);
                        });
                    }
                    console.log("- Winning party:", loc.winning_party);
                    console.log("- Winning share:", loc.winning_share);
                }
            }
            
            // Calculate totals from all locations
            allLocations.forEach(location => {
                location.parties.forEach(party => {
                    // Add this location's votes to the party total
                    if (party.name in partyVoteTotals) {
                        partyVoteTotals[party.name] += party.votes;
                        totalVotes += party.votes;
                    }
                });
            });
            
            // Convert to percentages and sort by vote share (descending)
            const partyShares = parties.map(party => ({
                name: party,
                votes: partyVoteTotals[party],
                share: totalVotes > 0 ? (partyVoteTotals[party] / totalVotes * 100) : 0,
                color: partyColors[party]
            })).sort((a, b) => b.share - a.share);
            
            // Create new legend with interactive elements
            legendControl = L.control({position: 'bottomright'});
            
            legendControl.onAdd = function() {
                const div = L.DomUtil.create('div', 'legend');
                
                // Add styles directly to the legend control
                div.style.maxHeight = '300px';
                div.style.overflowY = 'auto';
                div.style.padding = '10px';
                div.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
                div.style.border = '1px solid #ccc';
                div.style.borderRadius = '5px';
                
                // Create the legend content
                let legendContent = `
                    <h4 style="margin-top: 0; border-bottom: 1px solid #ccc; padding-bottom: 5px;">
                        Parties by Vote Share
                    </h4>
                    <div style="margin-bottom: 10px;">
                        <button id="select-all-parties" style="padding: 2px 5px; margin-right: 5px; font-size: 11px;">Select All</button>
                        <button id="deselect-all-parties" style="padding: 2px 5px; font-size: 11px;">Deselect All</button>
                    </div>
                    <div style="margin-bottom: 10px; font-size: 11px; color: #555; font-style: italic;">
                        Color intensity indicates vote share percentage:
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>Lower vote share (30%) = lighter shade</span>
                            <span>Higher vote share (70%+) = darker shade</span>
                        </div>
                        <div style="height: 10px; width: 100%; background: linear-gradient(to right, rgba(180,180,180,1), rgba(100,100,100,1));"></div>
                        <div style="margin-top: 3px;">Points with same party but different vote share vary in intensity</div>
                    </div>
                `;
                
                // Add each party with share and controls
                legendContent += partyShares.map(party => `
                    <div class="legend-item" style="display: flex; align-items: center; margin-bottom: 5px; padding: 3px 0;">
                        <input type="color" value="${party.color}" 
                               data-party="${party.name}" 
                               style="width: 20px; height: 20px; margin-right: 5px; cursor: pointer;"
                               title="Change color">
                        <input type="checkbox" checked data-party="${party.name}" 
                               style="margin-right: 5px; cursor: pointer;"
                               title="Show/hide party">
                        <span style="flex-grow: 1;">${party.name}</span>
                        <span style="font-size: 11px; color: #666;">${party.share.toFixed(1)}%</span>
                    </div>
                `).join('');
                
                // Add a footer with basemap selector
                legendContent += `
                    <div style="margin-top: 10px; border-top: 1px solid #ccc; padding-top: 5px;">
                        <label for="basemap-select" style="display: block; margin-bottom: 3px; font-size: 12px;">Basemap:</label>
                        <select id="basemap-select" style="width: 100%; padding: 3px; font-size: 12px;">
                            <option value="osm">OpenStreetMap</option>
                            <option value="simple" selected>Simple</option>
                            <option value="satellite">Satellite</option>
                            <option value="topo">Topographic</option>
                        </select>
                    </div>
                `;
                
                div.innerHTML = legendContent;
                
                // Prevent map interactions when clicking in the legend
                L.DomEvent.disableClickPropagation(div);
                L.DomEvent.disableScrollPropagation(div);
                
                // Add event listeners after the content is added to the DOM
                setTimeout(() => {
                    // Handle color picker changes
                    const colorPickers = div.querySelectorAll('input[type="color"]');
                    colorPickers.forEach(picker => {
                        picker.addEventListener('change', (e) => {
                            const party = e.target.dataset.party;
                            const newColor = e.target.value;
                            
                            // Update color in global map
                            partyColors[party] = newColor;
                            
                            // Refresh the map
                            updateDisplayLayers();
                        });
                    });
                    
                    // Handle checkbox changes
                    const checkboxes = div.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            const party = e.target.dataset.party;
                            const isVisible = e.target.checked;
                            
                            // Update the visibleParties set
                            if (isVisible) {
                                visibleParties.add(party);
                            } else {
                                visibleParties.delete(party);
                            }
                            
                            // Refresh the map with updated visibility
                            updateDisplayLayers();
                        });
                    });
                    
                    // Handle basemap selection
                    const basemapSelect = div.querySelector('#basemap-select');
                    if (basemapSelect) {
                        basemapSelect.addEventListener('change', (e) => {
                            changeBasemap(e.target.value);
                        });
                    }
                    
                    // Handle select/deselect all buttons
                    const selectAllBtn = div.querySelector('#select-all-parties');
                    const deselectAllBtn = div.querySelector('#deselect-all-parties');
                    
                    if (selectAllBtn) {
                        selectAllBtn.addEventListener('click', () => {
                            // Update all checkboxes
                            checkboxes.forEach(checkbox => {
                                checkbox.checked = true;
                            });
                            
                            // Add all parties to visibleParties
                            parties.forEach(party => {
                                visibleParties.add(party);
                            });
                            
                            // Refresh the map
                            updateDisplayLayers();
                        });
                    }
                    
                    if (deselectAllBtn) {
                        deselectAllBtn.addEventListener('click', () => {
                            // Update all checkboxes
                            checkboxes.forEach(checkbox => {
                                checkbox.checked = false;
                            });
                            
                            // Clear visibleParties
                            visibleParties.clear();
                            
                            // Refresh the map
                            updateDisplayLayers();
                        });
                    }
                }, 100);
                
                return div;
            };
            
            legendControl.addTo(map);
        }
        
        // Function to change the basemap
        function changeBasemap(type) {
            // Remove current tile layer
            map.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    map.removeLayer(layer);
                }
            });
            
            // Add the selected basemap
            switch(type) {
                case 'simple':
                    // Simple white background with minimal features
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>'
                    }).addTo(map);
                    break;
                    
                case 'satellite':
                    // Satellite imagery
                    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                    }).addTo(map);
                    break;
                    
                case 'topo':
                    // Topographic map
                    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
                    }).addTo(map);
                    break;
                    
                case 'osm':
                default:
                    // Default OpenStreetMap
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    }).addTo(map);
                    break;
            }
        }
        
        // Clear map data
        function clearMap() {
            if (markersLayer) markersLayer.clearLayers();
            if (legendControl) map.removeControl(legendControl);
        }
        
        // Fit map to bounds of current data
        function fitMapToBounds() {
            try {
                // Get all valid lat/lng pairs
                const validLocations = [];
                
                if (coordGroups) {
                    Object.values(coordGroups).forEach(coordGroup => {
                        const { latitude, longitude } = coordGroup;
                        
                        // Check for valid coordinates
                        if (latitude && longitude && 
                            !isNaN(parseFloat(latitude)) && 
                            !isNaN(parseFloat(longitude))) {
                            
                            // Check for valid range
                            const lat = parseFloat(latitude);
                            const lng = parseFloat(longitude);
                            
                            if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                                validLocations.push([lat, lng]);
                            }
                        }
                    });
                }
                
                console.log(`Found ${validLocations.length} valid locations for bounds`);
                
                if (validLocations.length > 0) {
                    // Create bounds and fit map
                    const bounds = L.latLngBounds(validLocations);
                    
                    // Calculate padding based on screen size - larger screens need more padding
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    const paddingX = Math.max(100, screenWidth * 0.15); // 15% of screen width or at least 100px
                    const paddingY = Math.max(80, screenHeight * 0.15);  // 15% of screen height or at least 80px
                    
                    map.fitBounds(bounds, {
                        padding: [paddingY, paddingX], // Add generous padding
                        maxZoom: 9        // Limit max zoom level for better overview
                    });
                    
                    console.log("Map view updated to fit data bounds");
                } else {
                    console.log("No valid coordinates to fit map bounds");
                    // If we don't have valid coordinates, set a default view
                    const countryName = countrySelect.value;
                    
                    // Set country-specific default views
                    const countryViews = {
                        'albania': { center: [41.3275, 19.8187], zoom: 7 },
                        'georgia': { center: [42.3154, 43.3569], zoom: 7 },
                        'montenegro': { center: [42.7087, 19.3744], zoom: 8 },
                        // Add more countries as needed
                        'default': { center: [20, 0], zoom: 2 }
                    };
                    
                    // Get the view based on country or use default
                    const view = countryViews[countryName.toLowerCase()] || countryViews.default;
                    
                    // Set the view
                    map.setView(view.center, view.zoom);
                }
            } catch (e) {
                console.error("Error fitting map to bounds:", e);
                // Default fallback view
                map.setView([20, 0], 2);
            }
        }
        
        // Show/hide loading indicator
        function showLoading(show) {
            loadingElement.style.display = show ? 'block' : 'none';
        }
        
        // Show/hide error message
        function showError(message) {
            if (message) {
                errorElement.textContent = message;
                errorElement.style.display = 'block';
            } else {
                errorElement.style.display = 'none';
            }
        }
        
        // Hide error message
        function hideError() {
            errorElement.style.display = 'none';
        }
        
        // Show success message
        function showSuccess(message) {
            if (message) {
                successElement.textContent = message;
                successElement.style.display = 'block';
                
                // Hide success message after 3 seconds
                setTimeout(() => {
                    hideSuccess();
                }, 3000);
            } else {
                successElement.style.display = 'none';
            }
        }
        
        // Hide success message
        function hideSuccess() {
            successElement.style.display = 'none';
        }
        
        // Handle scale points toggle
        function initScalePointsToggle() {
            const toggle = document.getElementById('scale-points-toggle');
            if (toggle) {
                toggle.checked = scalePointsByVotes;
                toggle.addEventListener('change', function() {
                    scalePointsByVotes = toggle.checked;
                    // Redraw all markers with new scaling
                    updateDisplayLayers();
                });
            }
        }
        
        // Handle opacity toggle (solid points vs. semi-transparent)
        function initOpacityToggle() {
            const toggle = document.getElementById('opacity-toggle');
            if (toggle) {
                toggle.checked = useSolidPoints;
                toggle.addEventListener('change', function() {
                    useSolidPoints = toggle.checked;
                    // Redraw all markers with new opacity settings
                    updateDisplayLayers();
                });
            }
        }
        
        // Save current layer
        function addCurrentLayerToMap() {
            const country = countrySelect.value;
            const year = yearSelect.value;
            const electionType = electionTypeSelect.value;
            
            if (!country || !year || !electionType) {
                showError("Please select a country, year, and election type first");
                return;
            }
            
            // Check if this layer already exists
            const layerId = `${country}-${year}-${electionType}`;
            const existingLayer = activeLayers.find(layer => layer.id === layerId);
            
            if (existingLayer) {
                showError("This layer is already added to the map");
                return;
            }
            
            // Get country display name
            const countryOption = countrySelect.querySelector(`option[value="${country}"]`);
            const countryName = countryOption ? countryOption.textContent : country;
            
            // Create layer object with clone of current data
            const newLayer = {
                id: layerId,
                country: country,
                countryName: countryName,
                year: year,
                electionType: electionType,
                coordGroups: JSON.parse(JSON.stringify(coordGroups)),
                markers: L.layerGroup(),
                partyColors: {...partyColors} // Clone current party colors
            };
            
            // Add to active layers
            activeLayers.push(newLayer);
            
            // Create markers for this layer
            renderLayerMarkers(newLayer);
            
            // Update UI
            updateLayerList();
            
            showSuccess(`Added layer: ${countryName} ${year} ${electionType}`);
        }
        
        // Render markers for a specific layer
        function renderLayerMarkers(layer) {
            // Clear previous markers
            layer.markers.clearLayers();
            
            // Create markers similar to renderMapData but for the layer
            Object.values(layer.coordGroups).forEach(coordGroup => {
                const { latitude, longitude, locations } = coordGroup;
                
                if (latitude && longitude && 
                    !isNaN(parseFloat(latitude)) && 
                    !isNaN(parseFloat(longitude))) {
                    
                    // Similar marker creation logic as in renderMapData
                    // Calculate color intensity based on vote share
                    const winningParty = locations[0].winning_party;
                    let voteShare = 0;
                    
                    // Try multiple ways to get the vote share
                    if (locations[0].winning_share) {
                        voteShare = locations[0].winning_share;
                    } else if (locations[0].parties && locations[0].parties.length > 0) {
                        const party = locations[0].parties.find(p => p.name === winningParty);
                        if (party && party.vote_share) {
                            voteShare = party.vote_share;
                        } else if (party && party.votes && locations[0].total_votes) {
                            // Calculate directly if we have votes and total_votes
                            voteShare = (party.votes / locations[0].total_votes) * 100;
                        }
                    }
                    
                    // Set full opacity - using color intensity for variation
                    const fillOpacity = 1.0;
                    
                    // Convert voteShare to a number to ensure proper math operations
                    const numericVoteShare = parseFloat(voteShare);
                    
                    // Calculate color based on vote share 
                    // We'll darken/lighten the base party color based on vote share
                    let markerColor = layer.partyColors[winningParty] || '#999';
                    
                    if (numericVoteShare > 0) {
                        // Get the base color for the party
                        const baseColor = layer.partyColors[winningParty] || '#999';
                        
                        // Convert to RGB to adjust brightness
                        const rgb = hexToRgb(baseColor);
                        if (rgb) {
                            // Cap vote share at 100% for calculation purposes
                            const cappedShare = Math.min(numericVoteShare, 100);
                            
                            // Low vote share (30%) = lighter (mix with white)
                            // High vote share (70%+) = darker/more saturated
                            
                            // Calculate brightness factor with more pronounced effect
                            // For low vote share (30%), factor is around 1.4 (much lighter)
                            // For high vote share (70%+), factor is around 0.3 (much darker)
                            // Make color intensity variation more dramatic - ranges from 0.4 to 1.4
                            const voteShareFactor = cappedShare / 100;
                            let brightnessFactor;
                            
                            if (voteShareFactor < 0.5) {
                                // For low vote shares, use a different formula to make them lighter
                                brightnessFactor = 1.4 - voteShareFactor;
                            } else {
                                // For high vote shares, make them progressively darker
                                brightnessFactor = 0.9 - (voteShareFactor - 0.5) * 1.0;
                            }
                            
                            // Adjust RGB values based on brightness factor
                            // Use Math.min to ensure we don't go above 255
                            const adjustedR = Math.min(255, Math.floor(rgb.r * brightnessFactor));
                            const adjustedG = Math.min(255, Math.floor(rgb.g * brightnessFactor));
                            const adjustedB = Math.min(255, Math.floor(rgb.b * brightnessFactor));
                            
                            // Convert back to hex
                            markerColor = rgbToHex(adjustedR, adjustedG, adjustedB);
                        }
                    }
                    
                    // Helper function to convert hex to RGB
                    function hexToRgb(hex) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                        
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                    }
                    
                    // Helper function to convert RGB to hex
                    function rgbToHex(r, g, b) {
                        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    }
                    
                    // Log color calculation for debugging
                    console.log(`Layer marker: voteShare=${numericVoteShare.toFixed(1)}%, color=${markerColor}`);
                    
                    // Create marker with different color or style to differentiate layers
                    const marker = L.circleMarker(
                        [parseFloat(latitude), parseFloat(longitude)], 
                        {
                            radius: 6, // Fixed size for layer markers
                            fillColor: markerColor,
                            color: '#000',
                            weight: 1.5,
                            opacity: 1,
                            fillOpacity: fillOpacity // Fixed opacity
                        }
                    );
                    
                    // Add popup showing this is part of a saved layer
                    marker.bindPopup(
                        `<div><strong>${layer.countryName} (${layer.year})</strong></div>` +
                        createPopupContent(locations).innerHTML
                    );
                    
                    // Add to layer's marker group
                    layer.markers.addLayer(marker);
                }
            });
            
            // Add the layer to the map
            layer.markers.addTo(map);
        }
        
        // Update the layer list UI
        function updateLayerList() {
            const layerList = document.getElementById('layer-list');
            
            // Clear current list
            layerList.innerHTML = '';
            
            if (activeLayers.length === 0) {
                layerList.innerHTML = '<div class="empty-message">No active layers</div>';
                return;
            }
            
            // Add each layer to the list
            activeLayers.forEach(layer => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                
                layerItem.innerHTML = `
                    <span>${layer.countryName} ${layer.year} ${layer.electionType}</span>
                    <button class="remove-layer" data-id="${layer.id}">Remove</button>
                `;
                
                layerList.appendChild(layerItem);
            });
            
            // Add event listeners for remove buttons
            const removeButtons = layerList.querySelectorAll('.remove-layer');
            removeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    removeLayer(button.dataset.id);
                });
            });
        }
        
        // Remove a layer from the map
        function removeLayer(layerId) {
            const layerIndex = activeLayers.findIndex(layer => layer.id === layerId);
            
            if (layerIndex >= 0) {
                // Remove layer from map
                map.removeLayer(activeLayers[layerIndex].markers);
                
                // Remove from array
                const removedLayer = activeLayers.splice(layerIndex, 1)[0];
                
                // Update UI
                updateLayerList();
                
                showSuccess(`Removed layer: ${removedLayer.countryName} ${removedLayer.year} ${removedLayer.electionType}`);
            }
        }
        
        // Clear all layers
        function clearAllLayers() {
            // Remove all layers from map
            activeLayers.forEach(layer => {
                map.removeLayer(layer.markers);
            });
            
            // Clear array
            activeLayers = [];
            
            // Update UI
            updateLayerList();
            
            showSuccess("All layers cleared");
        }
        
        // Initialize layer controls
        function initLayerControls() {
            const addButton = document.getElementById('add-current-layer');
            const clearButton = document.getElementById('clear-all-layers');
            
            if (addButton) {
                addButton.addEventListener('click', addCurrentLayerToMap);
            }
            
            if (clearButton) {
                clearButton.addEventListener('click', clearAllLayers);
            }
            
            // Initialize empty layer list
            updateLayerList();
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            initToggles(); // Use our combined toggle function instead of just scale points
            initLayerControls();
        });
    </script>
</body>
</html>