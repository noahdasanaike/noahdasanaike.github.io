<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Election Data Visualization</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <style>
        body, html {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        
        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .app-title {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        
        .app-title h1 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .app-title p {
            margin: 5px 0 0 0;
            font-size: 12px;
            color: #666;
        }
        
        .controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 280px;
        }
        
        .database-section {
            margin-bottom: 15px;
        }
        
        .database-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .database-section input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 12px;
        }
        
        .database-section button {
            background: #3388ff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        
        .database-section button:hover {
            background: #2b75e5;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 12px;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            background-color: white;
            box-sizing: border-box;
        }
        
        .status-messages {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 70%;
            max-width: 500px;
        }
        
        .loading, .error, .success {
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0.95;
        }
        
        .loading {
            background-color: #f8f9fa;
            color: #333;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            max-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .layer-control {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            max-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .layer-control h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .layer-list {
            margin-bottom: 10px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: #f8f8f8;
            border-radius: 3px;
        }
        
        .layer-item button {
            margin-left: auto;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .layer-actions {
            margin-top: 10px;
        }
        
        .layer-actions button {
            background: #3388ff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .color-box {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        
        .leaflet-popup-content {
            min-width: 200px;
        }
        
        .popup-content h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 16px;
        }
        
        .popup-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .popup-content th {
            text-align: left;
            padding: 4px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }
        
        .popup-content td {
            padding: 4px;
            border-bottom: 1px solid #f5f5f5;
        }
        
        .footer {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 0, 0, 0.6);
            font-size: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="app-title">
        <h1>Election Data Visualization</h1>
        <p>Interactive exploration of global election results</p>
    </div>
    
    <div class="controls-panel">
        <div class="database-section">
            <h3>Data Source</h3>
            <input type="text" id="data-base-url" placeholder="Enter base URL for data" value="https://storage.googleapis.com/sage_archive/">
            <button id="load-main-index">Load Data</button>
        </div>
        
        <div class="control-group">
            <label for="country-select">Country</label>
            <select id="country-select" disabled>
                <option value="">Select Country</option>
                <!-- Countries will be populated dynamically -->
            </select>
        </div>
        
        <div class="control-group">
            <label for="year-select">Year</label>
            <select id="year-select" disabled>
                <option value="">Select Year</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="election-type-select">Election Type</label>
            <select id="election-type-select" disabled>
                <option value="">Select Election Type</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="display-mode">Display Mode</label>
            <select id="display-mode">
                <option value="points">Points</option>
                <option value="polygons" disabled>Polygons (currently unavailable)</option>
                <option value="both" disabled>Both Points & Polygons (currently unavailable)</option>
            </select>
        </div>
    </div>
    
    <div class="status-messages">
        <div id="loading" class="loading" style="display: none;">
            Loading data, please wait...
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="success" class="success" style="display: none;"></div>
    </div>
    
    <div class="layer-control" id="layer-control">
        <h4>Map Layers</h4>
        <div id="layer-list" class="layer-list">
            <!-- Layer items will be added here dynamically -->
            <div class="empty-message">No active layers</div>
        </div>
        <div class="layer-actions">
            <button id="add-current-layer">Add Current Selection</button>
            <button id="clear-all-layers">Clear All</button>
        </div>
        <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <label for="scale-points-toggle" style="flex-grow: 1; font-size: 13px;">Scale Points by Votes:</label>
                <input type="checkbox" id="scale-points-toggle" checked>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <label for="opacity-toggle" style="flex-grow: 1; font-size: 13px;">Solid Points (No Transparency):</label>
                <input type="checkbox" id="opacity-toggle" checked>
            </div>
        </div>
    </div>
    
    <div class="footer">
        &copy; Election Data Visualization - 2025
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global variables
        let map;
        let markersLayer;
        let displayMode = 'points'; // Only points mode is available
        let coordGroups = {}; // Store coordinate groups for map data
        let allLocations = []; // Store all processed locations
        let scalePointsByVotes = true; // Whether to scale points by vote count
        let useSolidPoints = true; // Whether to use solid points (no transparency)
        let activeLayers = []; // Store active country layers
        let partyColors = {}; // Store colors assigned to parties
        
        // CSV data structure variables
        let mainIndexUrl = ''; // URL to the main countries-index.csv file
        let countriesIndex = []; // Main countries index
        let currentCountryIndex = []; // Index for currently selected country
        let dataBaseUrl = ''; // Base URL for data files
        
        // Coordinate conversion functions for dealing with projections
        
        // Convert WGS84 lat/lng to Web Mercator (EPSG:3857)
        function latLngToMercator(lat, lng) {
            // Constants
            const EARTH_RADIUS = 6378137; // Earth's radius in meters
            
            // Convert to radians
            const latRad = lat * Math.PI / 180;
            const lngRad = lng * Math.PI / 180;
            
            // Calculate mercator coordinates
            const mercatorX = EARTH_RADIUS * lngRad;
            const mercatorY = EARTH_RADIUS * Math.log(Math.tan(Math.PI / 4 + latRad / 2));
            
            return { mercatorX, mercatorY };
        }
        
        // Convert Web Mercator (EPSG:3857) to WGS84 lat/lng
        function mercatorToLatLng(x, y) {
            // Constants
            const EARTH_RADIUS = 6378137; // Earth's radius in meters
            
            // Calculate lat/lng in radians
            const lngRad = x / EARTH_RADIUS;
            const latRad = 2 * Math.atan(Math.exp(y / EARTH_RADIUS)) - Math.PI / 2;
            
            // Convert to degrees
            const lat = latRad * 180 / Math.PI;
            const lng = lngRad * 180 / Math.PI;
            
            return { lat, lng };
        }
        
        // More contrasting color palette with no yellows and better visual differentiation
        // Reordered with most distinctive colors first and purple moved down
        const colorPalette = [
            '#D32F2F', // Bright red
            '#1976D2', // Strong blue
            '#388E3C', // Deep green
            '#F57C00', // Orange
            '#C2185B', // Magenta
            '#0097A7', // Teal
            '#455A64', // Blue Gray
            '#7B1FA2', // Purple
            '#5D4037', // Brown
            '#00796B', // Dark Teal
            '#6D4C41', // Dark Brown
            '#512DA8', // Deep Purple
            '#004D40', // Darkest Teal
            '#3E2723', // Darkest Brown  
            '#263238'  // Darkest Blue Gray
        ];
        
        // DOM elements
        const dataBaseUrlInput = document.getElementById('data-base-url');
        const loadMainIndexButton = document.getElementById('load-main-index');
        const countrySelect = document.getElementById('country-select');
        const yearSelect = document.getElementById('year-select');
        const electionTypeSelect = document.getElementById('election-type-select');
        const displayModeSelect = document.getElementById('display-mode');
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('error');
        const successElement = document.getElementById('success');
        
        // Show/hide loading indicator
        function showLoading(isLoading) {
            loadingElement.style.display = isLoading ? 'block' : 'none';
        }
        
        // Show error message
        function showError(message) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 5000);
        }
        
        // Show success message
        function showSuccess(message) {
            successElement.textContent = message;
            successElement.style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                successElement.style.display = 'none';
            }, 3000);
        }
        
        // Initialize the map
        function initializeMap() {
            // Create the map - default to world view
            map = L.map('map').setView([20, 0], 2); // Centered on world by default
            
            // Add a simple light base map by default
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>',
                tms: false,
                detectRetina: true
            }).addTo(map);
            
            // Create layers for markers
            markersLayer = L.layerGroup();
            
            // Add marker layer
            markersLayer.addTo(map);
        }
        
        // Load the main countries index
        async function loadMainIndex() {
            showLoading(true);
            
            // Clear existing data
            countriesIndex = [];
            clearMap();
            resetSelectors();
            
            try {
                // Get base URL from input
                dataBaseUrl = dataBaseUrlInput.value.trim();
                if (!dataBaseUrl.endsWith('/')) {
                    dataBaseUrl += '/';
                }
                
                // Construct URL to main index file
                mainIndexUrl = dataBaseUrl + 'countries-index.csv';
                
                // Load and parse the main index CSV
                const response = await fetch(mainIndexUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load main index. Status: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using PapaParse
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // Store countries index
                        countriesIndex = results.data.filter(country => country.country_id);
                        
                        // Populate country selector
                        populateCountrySelector();
                        
                        showLoading(false);
                        showSuccess(`Loaded index with ${countriesIndex.length} countries`);
                    },
                    error: function(error) {
                        showError(`Error parsing countries index: ${error}`);
                        showLoading(false);
                    }
                });
            } catch (error) {
                showError(`Failed to load main index: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Populate the country selector dropdown
        function populateCountrySelector() {
            // Clear existing options except the first one
            while (countrySelect.options.length > 1) {
                countrySelect.remove(1);
            }
            
            // Sort countries alphabetically
            countriesIndex.sort((a, b) => a.country_name.localeCompare(b.country_name));
            
            // Add options for each country
            countriesIndex.forEach(country => {
                const option = document.createElement('option');
                option.value = country.country_id;
                option.textContent = country.country_name;
                countrySelect.appendChild(option);
            });
            
            // Enable country selector
            countrySelect.disabled = false;
            
            // Add event listener for country selection
            countrySelect.removeEventListener('change', loadCountryIndex);
            countrySelect.addEventListener('change', loadCountryIndex);
        }
        
        // Load the index for a specific country
        async function loadCountryIndex() {
            const selectedCountryId = countrySelect.value;
            
            if (!selectedCountryId) {
                resetYearSelector();
                return;
            }
            
            showLoading(true);
            clearMap();
            resetYearSelector();
            
            try {
                // Find the country in the index
                const country = countriesIndex.find(c => c.country_id === selectedCountryId);
                if (!country) {
                    throw new Error(`Country ${selectedCountryId} not found in index`);
                }
                
                // Construct URL to country index file
                const countryIndexUrl = dataBaseUrl + country.index_path;
                
                // Load and parse the country index CSV
                const response = await fetch(countryIndexUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load country index. Status: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using PapaParse
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // Store country index
                        currentCountryIndex = results.data.filter(entry => 
                            entry.file_path || entry.country); // Filter out empty rows
                        
                        // Populate year selector
                        populateYearSelector();
                        
                        showLoading(false);
                        showSuccess(`Loaded index for ${country.country_name}`);
                    },
                    error: function(error) {
                        showError(`Error parsing country index: ${error}`);
                        showLoading(false);
                    }
                });
            } catch (error) {
                showError(`Failed to load country index: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Populate the year selector dropdown
        function populateYearSelector() {
            // Clear existing options except the first one
            while (yearSelect.options.length > 1) {
                yearSelect.remove(1);
            }
            
            // Get unique years from the country index
            const yearsSet = new Set();
            
            currentCountryIndex.forEach(entry => {
                if (entry.year) {
                    yearsSet.add(entry.year);
                }
            });
            
            // Convert to array and sort in descending order (newest first)
            const years = Array.from(yearsSet).sort((a, b) => b - a);
            
            // Add options for each year
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            });
            
            // If there are entries without a year (like direct files), add a "No Year" option
            const hasEntriesWithoutYear = currentCountryIndex.some(entry => 
                entry.file_path && !entry.year);
                
            if (hasEntriesWithoutYear) {
                const option = document.createElement('option');
                option.value = "none";
                option.textContent = "No Year (Direct Files)";
                yearSelect.appendChild(option);
            }
            
            // Enable year selector
            yearSelect.disabled = false;
            
            // Add event listener for year selection
            yearSelect.removeEventListener('change', updateElectionTypeSelector);
            yearSelect.addEventListener('change', updateElectionTypeSelector);
        }
        
        // Update the election type selector based on the selected year
        function updateElectionTypeSelector() {
            const selectedYear = yearSelect.value;
            
            if (!selectedYear) {
                resetElectionTypeSelector();
                return;
            }
            
            // Clear existing options except the first one
            while (electionTypeSelect.options.length > 1) {
                electionTypeSelect.remove(1);
            }
            
            let filteredEntries;
            
            if (selectedYear === "none") {
                // Show entries without a year
                filteredEntries = currentCountryIndex.filter(entry => 
                    entry.file_path && !entry.year);
                    
                // These might have a different format, using data_type instead of election_type
                filteredEntries.forEach(entry => {
                    const displayName = entry.data_type || 
                                      (entry.file_path.split('/').pop().replace('.csv', ''));
                    
                    const option = document.createElement('option');
                    option.value = JSON.stringify({
                        file_path: entry.file_path,
                        name: displayName
                    });
                    option.textContent = displayName;
                    electionTypeSelect.appendChild(option);
                });
            } else {
                // Show election types for the selected year
                filteredEntries = currentCountryIndex.filter(entry => 
                    entry.year == selectedYear); // Use == to match string and number types
                
                // Group by election type
                const electionTypes = {};
                
                filteredEntries.forEach(entry => {
                    if (entry.election_type && entry.file_path) {
                        electionTypes[entry.election_type] = entry.file_path;
                    }
                });
                
                // Add options for each election type
                Object.keys(electionTypes).sort().forEach(type => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify({
                        file_path: electionTypes[type],
                        name: type
                    });
                    option.textContent = type;
                    electionTypeSelect.appendChild(option);
                });
            }
            
            // Enable election type selector if we have options
            electionTypeSelect.disabled = electionTypeSelect.options.length <= 1;
            
            // Add event listener for election type selection
            electionTypeSelect.removeEventListener('change', loadElectionData);
            electionTypeSelect.addEventListener('change', loadElectionData);
        }
        
        // Load the election data from the selected CSV file
        async function loadElectionData() {
            const selectedOption = electionTypeSelect.value;
            
            if (!selectedOption) {
                clearMap();
                return;
            }
            
            showLoading(true);
            clearMap();
            
            try {
                // Parse the file path from the selected option
                const optionData = JSON.parse(selectedOption);
                const filePath = optionData.file_path;
                const electionType = optionData.name;
                
                // Construct URL to the CSV file
                const csvUrl = dataBaseUrl + filePath;
                
                // Load and parse the CSV file
                const response = await fetch(csvUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load election data. Status: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using PapaParse
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // First check if we have data
                        if (results.data.length === 0) {
                            showError("No data found in the CSV file");
                            showLoading(false);
                            return;
                        }
                            
                        // Now identify the coordinate columns
                        const firstRow = results.data[0];
                        const keys = Object.keys(firstRow);
                        
                        // Look for latitude/longitude columns with various possible names
                        let latColumn = null;
                        let lngColumn = null;
                        
                        // Try exact matches first (most reliable)
                        for (const key of keys) {
                            const lowerKey = key.toLowerCase();
                            if (!latColumn && (lowerKey === 'latitude' || lowerKey === 'lat')) {
                                latColumn = key;
                            }
                            if (!lngColumn && (lowerKey === 'longitude' || lowerKey === 'lng' || lowerKey === 'long')) {
                                lngColumn = key;
                            }
                        }
                        
                        // If exact matches failed, try partial matches but be more careful
                        if (!latColumn || !lngColumn) {
                            for (const key of keys) {
                                const lowerKey = key.toLowerCase();
                                // For partial matches, only match at word boundaries
                                if (!latColumn && (
                                    lowerKey === 'y' || 
                                    lowerKey.startsWith('lat') || 
                                    lowerKey.endsWith('_lat') ||
                                    lowerKey.includes('_lat_')
                                )) {
                                    latColumn = key;
                                }
                                
                                if (!lngColumn && (
                                    lowerKey === 'x' || 
                                    lowerKey.startsWith('lon') || 
                                    lowerKey.endsWith('_lon') || 
                                    lowerKey.endsWith('_lng') ||
                                    lowerKey.includes('_lon_') ||
                                    lowerKey.includes('_lng_')
                                )) {
                                    lngColumn = key;
                                }
                            }
                        }
                        
                        // Show debug info about available columns
                        console.log("Available columns:", keys);
                        console.log(`Found coordinate columns: lat=${latColumn}, lng=${lngColumn}`);
                        
                        if (!latColumn || !lngColumn) {
                            // Show a more descriptive error with the available columns
                            showError(`Could not find latitude/longitude columns in the data. Available columns: ${keys.join(', ')}`);
                            showLoading(false);
                            return;
                        }
                        
                        // Let's examine the first row to see coordinate values
                        console.log(`First row lat value: ${firstRow[latColumn]}, lng value: ${firstRow[lngColumn]}`);
                        
                        // Filter rows with valid coordinates
                        const data = results.data.filter(row => 
                            row[latColumn] !== undefined && row[lngColumn] !== undefined && 
                            !isNaN(parseFloat(row[latColumn])) && 
                            !isNaN(parseFloat(row[lngColumn]))
                        );
                        
                        // Rename coordinates to standard lat/lng for consistency in the rest of the code
                        data.forEach(row => {
                            row.lat = row[latColumn];
                            row.lng = row[lngColumn];
                        });
                        
                        if (data.length === 0) {
                            showError("No valid coordinates found in the data");
                            showLoading(false);
                            return;
                        }
                        
                        // Process and display the election data
                        processElectionData(data, filePath, electionType);
                        
                        showLoading(false);
                        showSuccess(`Loaded ${data.length} data points`);
                    },
                    error: function(error) {
                        showError(`Error parsing election data: ${error}`);
                        showLoading(false);
                    }
                });
            } catch (error) {
                showError(`Failed to load election data: ${error.message}`);
                showLoading(false);
            }
        }
        
        // Process election data and prepare it for display
        function processElectionData(data, filePath, electionType) {
            // Reset data structures
            coordGroups = {};
            allLocations = [];
            partyColors = {};
            
            // Identify columns that might contain party data
            // Party columns often end with specific suffixes or contain keywords
            const partyColumns = {};
            const possibleVoteColumns = [];
            
            if (data.length > 0) {
                const firstRow = data[0];
                const allColumns = Object.keys(firstRow);
                
                // Debug output of available columns
                console.log("All columns in data:", allColumns);
                                
                // First check for a single "party" column - common in your dataset
                const partyCol = allColumns.find(col => 
                    col.toLowerCase() === 'party' || 
                    col.toLowerCase() === 'party_name' ||
                    col.toLowerCase() === 'partyname'
                );
                
                const votesCol = allColumns.find(col => 
                    col.toLowerCase() === 'votes' || 
                    col.toLowerCase() === 'party_votes' ||
                    col.toLowerCase() === 'partyvotes'
                );
                
                console.log(`Found party/votes columns: party=${partyCol}, votes=${votesCol}`);
                
                // If we have a simple party/votes structure, use that directly
                if (partyCol && votesCol) {
                    console.log(`Found simple party/votes structure: ${partyCol}/${votesCol}`);
                    partyColumns[partyCol] = votesCol;
                } else {
                    // Otherwise check for more complex party column patterns
                    allColumns.forEach(col => {
                        // Check for common patterns in party columns
                        if (col.match(/party[0-9]*(_name)?$/i) || 
                            col.match(/^p[0-9]+_n$/i) || 
                            col.toLowerCase().includes("party") ||
                            col.match(/^party_[a-z0-9_]+$/i) ||
                            col.match(/party_[a-z]/i)) {
                            
                            // Now find a corresponding vote column
                            const baseCol = col.replace(/_name$/i, '').replace(/_n$/i, '');
                            const voteCol = allColumns.find(c => 
                                c === `${baseCol}_votes` || 
                                c === `${baseCol}_v` ||
                                c === baseCol.replace('party', 'votes') ||
                                c === baseCol.replace('name', 'votes')
                            );
                            
                            if (voteCol) {
                                partyColumns[col] = voteCol;
                            } else {
                                // See if there's a 'votes' column that might pair with this party
                                const possibleVotes = allColumns.find(c => 
                                    c.toLowerCase() === 'votes' || 
                                    c.toLowerCase().includes('vote')
                                );
                                
                                if (possibleVotes) {
                                    partyColumns[col] = possibleVotes;
                                } else {
                                    // If we couldn't find a direct match, just collect the column
                                    // We'll try to pair it later
                                    possibleVoteColumns.push(col);
                                }
                            }
                        } else if (col.match(/votes[0-9]*$/i) || 
                                col.match(/^v[0-9]+$/i) ||
                                col.match(/^p[0-9]+_v$/i)) {
                            // Collect vote columns that we might need to pair later
                            possibleVoteColumns.push(col);
                        }
                    });
                }
                
                // If we didn't find any paired columns, look for p1, p2, p3, etc. pattern
                if (Object.keys(partyColumns).length === 0) {
                    // Look for pattern p1, p2, p3 (party names) and v1, v2, v3 (votes)
                    const partyNamePattern = /^p([0-9]+)$/i;
                    
                    allColumns.forEach(col => {
                        const match = col.match(partyNamePattern);
                        if (match) {
                            const partyNumber = match[1];
                            const voteCol = allColumns.find(c => 
                                c.toLowerCase() === `v${partyNumber}` ||
                                c.toLowerCase() === `votes${partyNumber}`
                            );
                            
                            if (voteCol) {
                                partyColumns[col] = voteCol;
                            }
                        }
                    });
                }
            }
            
            console.log("Detected party columns:", partyColumns);
            
            // Process each data point
            data.forEach(row => {
                // Basic validation - must have lat/lng
                if (!row.lat || !row.lng || 
                    isNaN(parseFloat(row.lat)) || 
                    isNaN(parseFloat(row.lng))) {
                    return;
                }
                
                const lat = parseFloat(row.lat);
                const lng = parseFloat(row.lng);
                
                // Create an identifier for this location to group points with the same coords
                const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                
                // Find location name from various possible columns
                const possibleNameFields = [
                    'name', 'NAME', 'title', 'location', 
                    'district', 'locality', 'municipality', 
                    'region', 'state', 'country', 'name1', 'name2', 'name3'
                ];
                
                let locationName = "Unknown Location";
                for (const field of possibleNameFields) {
                    if (row[field]) {
                        locationName = row[field];
                        break;
                    }
                }
                
                // Find hierarchical names (name1, name2, etc.) for better display
                const nameHierarchy = [];
                for (let i = 1; i <= 5; i++) {
                    const nameField = `name${i}`;
                    if (row[nameField]) {
                        nameHierarchy.push(row[nameField]);
                    }
                }
                
                // If we have a hierarchy, use it for the name
                if (nameHierarchy.length > 0) {
                    locationName = nameHierarchy.join(', ');
                }
                
                // Find total votes from various possible columns
                const possibleTotalVotesFields = [
                    'total_votes', 'votes_total', 'totalvotes', 
                    'valid_votes', 'valid_ballots', 'valid'
                ];
                
                let totalVotes = 0;
                let totalVotesSource = null;
                
                for (const field of possibleTotalVotesFields) {
                    if (row[field] !== undefined && !isNaN(parseFloat(row[field]))) {
                        totalVotes = parseFloat(row[field]);
                        totalVotesSource = field;
                        break;
                    }
                }
                
                // If we didn't find total votes, try other approaches
                if (totalVotes === 0) {
                    // Try the "votes" column directly
                    if (row.votes !== undefined && !isNaN(parseFloat(row.votes))) {
                        totalVotes = parseFloat(row.votes);
                        totalVotesSource = "votes column";
                    }
                    // Or try party votes if available
                    else if (Object.keys(partyColumns).length > 0) {
                        try {
                            // For the simple case of one party per row
                            const entries = Object.entries(partyColumns);
                            if (entries.length > 0) {
                                const [nameCol, voteCol] = entries[0];
                                if (row[voteCol] !== undefined && !isNaN(parseFloat(row[voteCol]))) {
                                    totalVotes = parseFloat(row[voteCol]);
                                    totalVotesSource = "party votes";
                                }
                            }
                        } catch (e) {
                            console.error("Error calculating total votes from party data:", e);
                        }
                    }
                }
                
                console.log(`Total votes: ${totalVotes} (source: ${totalVotesSource})`);
                
                // Find registered voters from various possible columns
                const possibleRegFields = [
                    'reg', 'registered', 'evp', 'eligible', 
                    'registered_voters', 'electorate'
                ];
                
                let registeredVoters = 0;
                for (const field of possibleRegFields) {
                    if (row[field] && !isNaN(parseFloat(row[field]))) {
                        registeredVoters = parseFloat(row[field]);
                        break;
                    }
                }
                
                // Find turnout from various possible columns or calculate it
                let turnout = null;
                if (row.turnout && !isNaN(parseFloat(row.turnout))) {
                    turnout = parseFloat(row.turnout);
                } else if (row.turnout_reg && !isNaN(parseFloat(row.turnout_reg))) {
                    turnout = parseFloat(row.turnout_reg);
                } else if (totalVotes > 0 && registeredVoters > 0) {
                    turnout = totalVotes / registeredVoters;
                }
                
                // Prepare location data with all the fields we found
                const location = {
                    latitude: lat,
                    longitude: lng,
                    name: locationName,
                    total_votes: totalVotes,
                    reg: registeredVoters,
                    turnout: turnout,
                    // Store the full row data for detailed popup
                    fullDetails: { ...row },
                    nameHierarchy: nameHierarchy,
                    parties: []
                };
                
                // The Albania data has a multi-row structure where each row represents one party's
                // votes at one polling station. We need to extract the party data accurately.
                
                // First check if this is the expected format for Albania data
                // These rows should have party, party_b, and votes columns
                if (row.party !== undefined && row.votes !== undefined) {
                    // Construct full party name from party, party_b, and party_c
                    let partyName = row.party || "";
                    
                    // Add secondary party name fields if available
                    if (row.party_b) {
                        partyName += (partyName ? "\n" : "") + row.party_b;
                    }
                    
                    // Add abbreviation if available
                    if (row.party_c) {
                        partyName += (partyName ? "\n" : "") + row.party_c;
                    }
                    
                    // Convert votes to number
                    const votes = typeof row.votes === 'number' ? row.votes : parseInt(row.votes) || 0;
                    
                    // Add this party to the location
                    location.parties.push({
                        name: partyName || "Unknown Party",
                        votes: votes,
                        vote_share: votes / (location.total_votes || 1)
                    });
                    
                    console.log(`Extracted party: ${partyName}, votes: ${votes}`);
                } 
                // Try alternate capitalized column names
                else if (row.Party !== undefined && row.Votes !== undefined) {
                    const votes = typeof row.Votes === 'number' ? row.Votes : parseInt(row.Votes) || 0;
                    
                    location.parties.push({
                        name: row.Party,
                        votes: votes,
                        vote_share: votes / (location.total_votes || 1)
                    });
                    
                    console.log(`Extracted capitalized party: ${row.Party}, votes: ${votes}`);
                }
                // If direct methods failed, check for the expected column structure 
                // and any other potential party data in the row
                else {
                    if (Object.keys(partyColumns).length === 1) {
                        // If we have only one party column but multiple rows per location,
                        // this means each row is a different party for the same location
                        const [[nameCol, voteCol]] = Object.entries(partyColumns);
                        
                        if (row[nameCol] && row[voteCol] !== undefined) {
                            // Convert string vote count to number if needed
                            const voteCount = typeof row[voteCol] === 'number' 
                                ? row[voteCol] 
                                : parseInt(row[voteCol]) || 0;
                                
                            location.parties.push({
                                name: row[nameCol],
                                votes: voteCount,
                                vote_share: voteCount / (location.total_votes || 1)
                            });
                            
                            console.log(`Added party from column: ${row[nameCol]}, votes: ${voteCount}`);
                        }
                    } else {
                        // Multiple party columns in a single row
                        Object.entries(partyColumns).forEach(([nameCol, voteCol]) => {
                            if (row[nameCol] && row[voteCol] !== undefined) {
                                // Convert string vote count to number if needed
                                const voteCount = typeof row[voteCol] === 'number' 
                                    ? row[voteCol] 
                                    : parseInt(row[voteCol]) || 0;
                                    
                                location.parties.push({
                                    name: row[nameCol],
                                    votes: voteCount,
                                    vote_share: voteCount / (location.total_votes || 1)
                                });
                                
                                console.log(`Added party from multiple cols: ${row[nameCol]}, votes: ${voteCount}`);
                            }
                        });
                    }
                }
                
                // Find the winning party
                if (location.parties.length > 0) {
                    // Sort by votes (descending)
                    location.parties.sort((a, b) => b.votes - a.votes);
                    location.winning_party = location.parties[0].name;
                    location.winning_share = location.parties[0].vote_share;
                } else {
                    location.winning_party = "Unknown";
                    location.winning_share = 0;
                }
                
                // We need to group locations by NAME1-4 values to represent the same physical location
                // Each entry with the same location but different party should add to that location's parties array
                let locationKey = '';
                
                // Create a key based on the name hierarchy if available
                if (location.nameHierarchy && location.nameHierarchy.length > 0) {
                    locationKey = location.nameHierarchy.join('|');
                } else {
                    locationKey = location.name;
                }
                
                const fullLocationKey = `${lat},${lng},${locationKey}`;
                
                // Add to coordinate group
                if (!coordGroups[coordKey]) {
                    coordGroups[coordKey] = {
                        latitude: lat,
                        longitude: lng,
                        locations: {},  // Use an object instead of array to track by locationKey
                        locationKeys: new Set() // Track unique locations
                    };
                }
                
                // See if we've already added this exact location
                if (!coordGroups[coordKey].locationKeys.has(fullLocationKey)) {
                    // First time seeing this location, add it
                    coordGroups[coordKey].locationKeys.add(fullLocationKey);
                    coordGroups[coordKey].locations[fullLocationKey] = location;
                    allLocations.push(location);
                    console.log(`Added new location: ${location.name} at ${lat},${lng}`);
                } else {
                    // We've seen this location before, add this party to its parties array
                    const existingLocation = coordGroups[coordKey].locations[fullLocationKey];
                    
                    // Add all parties from this row to the existing location
                    if (location.parties.length > 0) {
                        location.parties.forEach(party => {
                            // Check if this party already exists
                            const existingParty = existingLocation.parties.find(p => p.name === party.name);
                            if (!existingParty) {
                                existingLocation.parties.push(party);
                                console.log(`Added party ${party.name} to existing location ${location.name}`);
                            }
                        });
                    }
                }
            });
            
            // Assign colors to parties
            const allParties = new Set();
            
            allLocations.forEach(location => {
                location.parties.forEach(party => {
                    allParties.add(party.name);
                });
            });
            
            // Convert to array and sort
            const partiesArray = Array.from(allParties);
            
            // Sort parties alphabetically for consistent color assignment
            partiesArray.sort();
            
            // Assign colors from our palette to each party
            partiesArray.forEach((party, index) => {
                partyColors[party] = colorPalette[index % colorPalette.length];
                console.log(`Assigned color ${colorPalette[index % colorPalette.length]} to party ${party}`);
            });
            
            // Create legend
            createLegend(partiesArray);
            
            // Render the data on the map
            renderMapData();
            
            // Zoom map to fit all data points
            if (Object.keys(coordGroups).length > 0) {
                // Create a bounds object
                const bounds = L.latLngBounds();
                
                // Add each coordinate to the bounds
                Object.values(coordGroups).forEach(group => {
                    bounds.extend([group.latitude, group.longitude]);
                });
                
                // Fit the map to these bounds (with padding)
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Create a legend showing party colors
        function createLegend(parties) {
            // Remove existing legend if it exists
            const existingLegend = document.querySelector('.legend');
            if (existingLegend) {
                existingLegend.remove();
            }
            
            // Create a new legend
            const legend = document.createElement('div');
            legend.className = 'legend';
            legend.innerHTML = '<h4>Winning Parties</h4>';
            
            // Sort parties alphabetically
            parties.sort();
            
            // Add each party to the legend
            parties.forEach(party => {
                const color = partyColors[party] || '#999';
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                
                const partyName = document.createElement('span');
                // Truncate very long party names
                partyName.textContent = party.length > 25 ? party.substring(0, 22) + '...' : party;
                
                item.appendChild(colorBox);
                item.appendChild(partyName);
                legend.appendChild(item);
            });
            
            document.body.appendChild(legend);
        }
        
        // Render the processed data on the map
        function renderMapData() {
            // Clear previous markers
            markersLayer.clearLayers();
            
            // Create markers for each coordinate group
            Object.values(coordGroups).forEach(coordGroup => {
                const { latitude, longitude, locations, locationKeys } = coordGroup;
                
                if (latitude && longitude && 
                    !isNaN(parseFloat(latitude)) && 
                    !isNaN(parseFloat(longitude))) {
                    
                    // Convert the locations object to an array for rendering
                    const locationsArray = Object.values(locations);
                    
                    // Make sure we have locations
                    if (locationsArray.length === 0) {
                        return;
                    }
                    
                    // Find the location with the most total votes for display
                    let primaryLocation = locationsArray[0];
                    locationsArray.forEach(loc => {
                        if (loc.total_votes > primaryLocation.total_votes) {
                            primaryLocation = loc;
                        }
                    });
                    
                    // Calculate marker properties based on the data
                    let radius = 6; // Default radius
                    let opacity = useSolidPoints ? 1.0 : 0.7; // Default opacity
                    
                    // Scale the marker size based on the number of votes if enabled
                    if (scalePointsByVotes && primaryLocation.total_votes) {
                        // Use a logarithmic scale for better visualization
                        const votes = primaryLocation.total_votes;
                        radius = Math.max(5, Math.min(15, 3 + Math.log10(votes) * 1.5));
                    }
                    
                    // Make sure the parties are sorted by votes to find the winning party
                    if (primaryLocation.parties && primaryLocation.parties.length > 0) {
                        // Sort parties by votes (descending)
                        primaryLocation.parties.sort((a, b) => b.votes - a.votes);
                        
                        // Update the winning party
                        primaryLocation.winning_party = primaryLocation.parties[0].name;
                        primaryLocation.winning_share = primaryLocation.parties[0].vote_share;
                    }
                    
                    // Get the winning party (the first party after sorting)
                    const winningParty = primaryLocation.winning_party;
                    
                    // Get the base color from the legend
                    let markerColor = partyColors[winningParty] || '#999';
                    
                    // Calculate color intensity based on vote share
                    const numericVoteShare = parseFloat(primaryLocation.winning_share) || 0.5;
                    
                    // Adjust color intensity based on vote share
                    if (numericVoteShare > 0) {
                        // Get the base color for the party
                        const baseColor = partyColors[winningParty] || '#999';
                        
                        // Convert to RGB to adjust brightness
                        const rgb = hexToRgb(baseColor);
                        if (rgb) {
                            // Cap vote share at 100% for calculation purposes
                            const cappedShare = Math.min(numericVoteShare, 1.0);
                            
                            // Calculate brightness factor
                            const voteShareFactor = cappedShare;
                            let brightnessFactor;
                            
                            if (voteShareFactor < 0.5) {
                                // For low vote shares, use a different formula to make them lighter
                                brightnessFactor = 1.4 - voteShareFactor;
                            } else {
                                // For high vote shares, make them progressively darker
                                brightnessFactor = 0.9 - (voteShareFactor - 0.5) * 1.0;
                            }
                            
                            // Adjust RGB values based on brightness factor
                            const adjustedR = Math.min(255, Math.floor(rgb.r * brightnessFactor));
                            const adjustedG = Math.min(255, Math.floor(rgb.g * brightnessFactor));
                            const adjustedB = Math.min(255, Math.floor(rgb.b * brightnessFactor));
                            
                            // Convert back to hex
                            markerColor = rgbToHex(adjustedR, adjustedG, adjustedB);
                        }
                    }
                    
                    // Log the color assignment for debugging
                    console.log(`Winning party: ${winningParty}, Color: ${markerColor}`);
                    
                    // Create the marker
                    const marker = L.circleMarker(
                        [parseFloat(latitude), parseFloat(longitude)], 
                        {
                            radius: radius,
                            fillColor: markerColor,
                            color: '#000',
                            weight: 1,
                            opacity: 0.8,
                            fillOpacity: opacity
                        }
                    );
                    
                    // Log party information for debugging
                    console.log(`Marker at ${latitude},${longitude} has ${locationsArray.length} locations`);
                    locationsArray.forEach(loc => {
                        console.log(`Location ${loc.name} has ${loc.parties.length} parties`);
                        loc.parties.forEach(p => console.log(`  ${p.name}: ${p.votes} votes`));
                    });
                    
                    // Add popup with location details
                    marker.bindPopup(createPopupContent(locationsArray));
                    
                    // Add to markers layer
                    markersLayer.addLayer(marker);
                }
            });
        }
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
            
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Helper function to convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // Create popup content for markers
        function createPopupContent(locations) {
            const content = document.createElement('div');
            content.className = 'popup-content';
            
            // Only keep unique locations based on their nameHierarchy
            let uniqueLocations = [];
            
            // Create a map to track unique locations
            const locationMap = new Map();
            
            // Process each location
            locations.forEach(loc => {
                // Create a key based on name hierarchy (or just name if no hierarchy)
                let key;
                if (loc.nameHierarchy && loc.nameHierarchy.length > 0) {
                    key = loc.nameHierarchy.join('|');
                } else {
                    key = loc.name;
                }
                
                // If we haven't seen this location, add it
                if (!locationMap.has(key)) {
                    locationMap.set(key, loc);
                }
            });
            
            // Convert map values to array
            uniqueLocations = Array.from(locationMap.values());
            
            // Debug output
            console.log(`Processed ${locations.length} locations into ${uniqueLocations.length} unique ones`);
            
            // If there's only one unique location, show its details
            if (uniqueLocations.length === 1) {
                const location = uniqueLocations[0];
                
                // Set the title using the name or first level of hierarchy
                const title = document.createElement('h3');
                title.textContent = location.name;
                content.appendChild(title);
                
                // If we have a name hierarchy, show it
                if (location.nameHierarchy && location.nameHierarchy.length > 0) {
                    const hierarchy = document.createElement('p');
                    hierarchy.style.fontSize = '12px';
                    hierarchy.style.fontStyle = 'italic';
                    hierarchy.style.marginTop = '-8px';
                    hierarchy.style.marginBottom = '10px';
                    
                    // Just use the original column names (NAME1, NAME2, etc.)
                    const hierarchyItems = location.nameHierarchy.map((name, index) => {
                        const label = `NAME${index+1}`;
                        return `<strong>${label}:</strong> ${name}`;
                    });
                    
                    hierarchy.innerHTML = hierarchyItems.join('<br>');
                    content.appendChild(hierarchy);
                }
                
                // Create a basic info section
                const info = document.createElement('p');
                
                // Start with total votes which should always be present
                let infoHTML = `<strong>Total Votes:</strong> ${location.total_votes.toLocaleString()}<br>`;
                
                // Add registered voters if available
                if (location.reg) {
                    infoHTML += `<strong>Registered Voters:</strong> ${location.reg.toLocaleString()}<br>`;
                }
                
                // Add turnout if available
                if (location.turnout) {
                    infoHTML += `<strong>Turnout:</strong> ${(location.turnout * 100).toFixed(1)}%<br>`;
                }
                
                // Add additional metadata if available
                if (location.fullDetails.geometry_type) {
                    infoHTML += `<strong>Geometry Type:</strong> ${location.fullDetails.geometry_type}<br>`;
                }
                
                if (location.fullDetails.geometry_type_b) {
                    infoHTML += `<strong>Data Source:</strong> ${location.fullDetails.geometry_type_b}<br>`;
                }
                
                info.innerHTML = infoHTML;
                content.appendChild(info);
                
                // Create a scrollable container for the table
                const tableContainer = document.createElement('div');
                tableContainer.style.maxHeight = '200px';
                tableContainer.style.overflowY = 'auto';
                tableContainer.style.marginTop = '10px';
                
                // Show party data in a table
                if (location.parties && location.parties.length > 0) {
                    // Log party data for debugging
                    console.log("Popup - Party data:", location.parties);
                    
                    // Sort parties by votes (descending)
                    const sortedParties = [...location.parties].sort((a, b) => (b.votes || 0) - (a.votes || 0));
                    
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    
                    // Handle null/undefined votes safely
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th>Party</th>
                                <th>Votes</th>
                                <th>Share</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sortedParties.map(party => {
                                const votes = party.votes || 0;
                                const voteShare = party.vote_share || 0;
                                return `
                                <tr>
                                    <td>${party.name || 'Unknown'}</td>
                                    <td>${votes.toLocaleString()}</td>
                                    <td>${(voteShare * 100).toFixed(1)}%</td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                    `;
                    
                    tableContainer.appendChild(table);
                    content.appendChild(tableContainer);
                }
            } else {
                // Multiple unique locations at the same coordinates
                // Create a dropdown selector like the old version
                const title = document.createElement('h3');
                title.textContent = `${uniqueLocations.length} Locations`;
                content.appendChild(title);
                
                // Create a dropdown select element
                const selectContainer = document.createElement('div');
                selectContainer.style.marginBottom = '10px';
                
                const label = document.createElement('label');
                label.textContent = 'Select a location: ';
                label.style.fontWeight = 'bold';
                label.style.fontSize = '14px';
                selectContainer.appendChild(label);
                
                const select = document.createElement('select');
                select.style.width = '100%';
                select.style.marginTop = '5px';
                select.style.padding = '5px';
                select.style.borderRadius = '4px';
                
                // Add options for each location
                uniqueLocations.forEach((location, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    
                    // Create descriptive label for the location
                    let label = "";
                    if (location.nameHierarchy && location.nameHierarchy.length > 0) {
                        // Use name4 if available 
                        const name4 = location.nameHierarchy[3];
                        if (name4) {
                            label = `${location.nameHierarchy[0]}, ${location.nameHierarchy[1]}, ${location.nameHierarchy[2]}, ${name4}`;
                        } else {
                            label = location.nameHierarchy.join(', ');
                        }
                    } else {
                        label = location.name;
                    }
                    
                    option.textContent = label;
                    select.appendChild(option);
                });
                
                selectContainer.appendChild(select);
                content.appendChild(selectContainer);
                
                // Create a container for the details
                const detailsContainer = document.createElement('div');
                detailsContainer.id = 'location-details';
                content.appendChild(detailsContainer);
                
                // Function to show selected location details
                const showLocationDetails = () => {
                    const selectedIndex = parseInt(select.value);
                    const selectedLocation = uniqueLocations[selectedIndex];
                    
                    // Create details for this location
                    const details = document.createElement('div');
                    
                    // Create location details similar to single location display
                    // Simplified version with just the party table
                    
                    // Show party data in a table
                    if (selectedLocation.parties && selectedLocation.parties.length > 0) {
                        // Create a basic info section first
                        const info = document.createElement('p');
                        
                        // Start with total votes which should always be present
                        let infoHTML = `<strong>Total Votes:</strong> ${selectedLocation.total_votes.toLocaleString()}<br>`;
                        
                        // Add registered voters if available
                        if (selectedLocation.reg) {
                            infoHTML += `<strong>Registered Voters:</strong> ${selectedLocation.reg.toLocaleString()}<br>`;
                        }
                        
                        // Add turnout if available
                        if (selectedLocation.turnout) {
                            infoHTML += `<strong>Turnout:</strong> ${(selectedLocation.turnout * 100).toFixed(1)}%<br>`;
                        }
                        
                        info.innerHTML = infoHTML;
                        details.appendChild(info);
                        
                        // Create party table
                        const tableContainer = document.createElement('div');
                        tableContainer.style.maxHeight = '200px';
                        tableContainer.style.overflowY = 'auto';
                        
                        // Sort parties by votes
                        const sortedParties = [...selectedLocation.parties].sort((a, b) => (b.votes || 0) - (a.votes || 0));
                        
                        const table = document.createElement('table');
                        table.style.width = '100%';
                        
                        // Handle null/undefined votes safely
                        table.innerHTML = `
                            <thead>
                                <tr>
                                    <th>Party</th>
                                    <th>Votes</th>
                                    <th>Share</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedParties.map(party => {
                                    const votes = party.votes || 0;
                                    const voteShare = party.vote_share || 0;
                                    return `
                                    <tr>
                                        <td>${party.name || 'Unknown'}</td>
                                        <td>${votes.toLocaleString()}</td>
                                        <td>${(voteShare * 100).toFixed(1)}%</td>
                                    </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        `;
                        
                        tableContainer.appendChild(table);
                        details.appendChild(tableContainer);
                    } else {
                        const noData = document.createElement('p');
                        noData.textContent = 'No party data available for this location.';
                        details.appendChild(noData);
                    }
                    
                    // Update the details container
                    detailsContainer.innerHTML = '';
                    detailsContainer.appendChild(details);
                };
                
                // Show first location by default
                showLocationDetails();
                
                // Add change event to select
                select.addEventListener('change', showLocationDetails);
            }
            
            return content;
        }
        
        // Add the current layer to the map
        function addCurrentLayerToMap() {
            // Get current selections
            const countryId = countrySelect.value;
            const yearVal = yearSelect.value;
            const electionTypeOption = electionTypeSelect.value;
            
            if (!countryId || !yearVal || !electionTypeOption) {
                showError('Please select a country, year, and election type first');
                return;
            }
            
            // Find the country name
            const country = countriesIndex.find(c => c.country_id === countryId);
            if (!country) {
                showError('Country not found');
                return;
            }
            
            // Parse the election type data
            let electionTypeName = '';
            try {
                const optionData = JSON.parse(electionTypeOption);
                electionTypeName = optionData.name;
            } catch (e) {
                showError('Invalid election type data');
                return;
            }
            
            // Create a unique ID for this layer
            const layerId = `${countryId}_${yearVal}_${electionTypeName}`.replace(/\s+/g, '_');
            
            // Check if this layer already exists
            if (activeLayers.some(layer => layer.id === layerId)) {
                showError('This layer is already added to the map');
                return;
            }
            
            // Create a new layer
            const newLayer = {
                id: layerId,
                countryName: country.country_name,
                year: yearVal === 'none' ? 'No Year' : yearVal,
                electionType: electionTypeName,
                coordGroups: JSON.parse(JSON.stringify(coordGroups)), // Deep copy
                partyColors: { ...partyColors }, // Copy party colors
                markers: L.layerGroup()
            };
            
            // Add to active layers array
            activeLayers.push(newLayer);
            
            // Render markers for this layer
            renderLayerMarkers(newLayer);
            
            // Update the layer list UI
            updateLayerList();
            
            showSuccess(`Added layer: ${newLayer.countryName} ${newLayer.year} ${newLayer.electionType}`);
        }
        
        // Render markers for a specific layer
        function renderLayerMarkers(layer) {
            // Clear previous markers
            layer.markers.clearLayers();
            
            // Create markers similar to renderMapData but for the layer
            Object.values(layer.coordGroups).forEach(coordGroup => {
                const { latitude, longitude, locations } = coordGroup;
                
                if (latitude && longitude && 
                    !isNaN(parseFloat(latitude)) && 
                    !isNaN(parseFloat(longitude))) {
                    
                    // Calculate marker properties based on the data
                    let radius = 6; // Default radius for layer markers
                    
                    // Make sure the parties are sorted by votes to find the winning party
                    if (locations[0].parties && locations[0].parties.length > 0) {
                        // Sort parties by votes (descending)
                        locations[0].parties.sort((a, b) => b.votes - a.votes);
                        
                        // Update the winning party
                        locations[0].winning_party = locations[0].parties[0].name;
                        locations[0].winning_share = locations[0].parties[0].vote_share;
                    }
                    
                    // Get the winning party
                    const winningParty = locations[0].winning_party;
                    
                    // Get the base color for the party
                    let markerColor = layer.partyColors[winningParty] || '#999';
                    
                    // Calculate color intensity based on vote share
                    const numericVoteShare = parseFloat(locations[0].winning_share) || 0.5;
                    
                    if (numericVoteShare > 0) {
                        // Get the base color for the party
                        const baseColor = layer.partyColors[winningParty] || '#999';
                        
                        // Convert to RGB to adjust brightness
                        const rgb = hexToRgb(baseColor);
                        if (rgb) {
                            const cappedShare = Math.min(numericVoteShare, 1.0);
                            
                            // Calculate brightness factor
                            const voteShareFactor = cappedShare;
                            let brightnessFactor;
                            
                            if (voteShareFactor < 0.5) {
                                brightnessFactor = 1.4 - voteShareFactor;
                            } else {
                                brightnessFactor = 0.9 - (voteShareFactor - 0.5) * 1.0;
                            }
                            
                            // Adjust RGB values
                            const adjustedR = Math.min(255, Math.floor(rgb.r * brightnessFactor));
                            const adjustedG = Math.min(255, Math.floor(rgb.g * brightnessFactor));
                            const adjustedB = Math.min(255, Math.floor(rgb.b * brightnessFactor));
                            
                            // Convert back to hex
                            markerColor = rgbToHex(adjustedR, adjustedG, adjustedB);
                        }
                    }
                    
                    // Log the color assignment for debugging
                    console.log(`Layer marker - Winning party: ${winningParty}, Color: ${markerColor}`);
                    
                    // Create marker with different color or style to differentiate layers
                    const marker = L.circleMarker(
                        [parseFloat(latitude), parseFloat(longitude)], 
                        {
                            radius: radius,
                            fillColor: markerColor,
                            color: '#000',
                            weight: 1.5,
                            opacity: 1,
                            fillOpacity: 1.0 // Fixed opacity for layer markers
                        }
                    );
                    
                    // Add popup showing this is part of a saved layer
                    marker.bindPopup(
                        `<div><strong>${layer.countryName} (${layer.year})</strong></div>` +
                        createPopupContent(locations).innerHTML
                    );
                    
                    // Add to layer's marker group
                    layer.markers.addLayer(marker);
                }
            });
            
            // Add the layer to the map
            layer.markers.addTo(map);
        }
        
        // Update the layer list UI
        function updateLayerList() {
            const layerList = document.getElementById('layer-list');
            
            // Clear current list
            layerList.innerHTML = '';
            
            if (activeLayers.length === 0) {
                layerList.innerHTML = '<div class="empty-message">No active layers</div>';
                return;
            }
            
            // Add each layer to the list
            activeLayers.forEach(layer => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                
                layerItem.innerHTML = `
                    <span>${layer.countryName} ${layer.year} ${layer.electionType}</span>
                    <button class="remove-layer" data-id="${layer.id}">Remove</button>
                `;
                
                layerList.appendChild(layerItem);
            });
            
            // Add event listeners for remove buttons
            const removeButtons = layerList.querySelectorAll('.remove-layer');
            removeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    removeLayer(button.dataset.id);
                });
            });
        }
        
        // Remove a layer from the map
        function removeLayer(layerId) {
            const layerIndex = activeLayers.findIndex(layer => layer.id === layerId);
            
            if (layerIndex >= 0) {
                // Remove layer from map
                map.removeLayer(activeLayers[layerIndex].markers);
                
                // Remove from array
                const removedLayer = activeLayers.splice(layerIndex, 1)[0];
                
                // Update UI
                updateLayerList();
                
                showSuccess(`Removed layer: ${removedLayer.countryName} ${removedLayer.year} ${removedLayer.electionType}`);
            }
        }
        
        // Clear all layers
        function clearAllLayers() {
            // Remove all layers from map
            activeLayers.forEach(layer => {
                map.removeLayer(layer.markers);
            });
            
            // Clear array
            activeLayers = [];
            
            // Update UI
            updateLayerList();
            
            showSuccess("All layers cleared");
        }
        
        // Initialize layer controls
        function initLayerControls() {
            const addButton = document.getElementById('add-current-layer');
            const clearButton = document.getElementById('clear-all-layers');
            
            if (addButton) {
                addButton.addEventListener('click', addCurrentLayerToMap);
            }
            
            if (clearButton) {
                clearButton.addEventListener('click', clearAllLayers);
            }
            
            // Initialize empty layer list
            updateLayerList();
        }
        
        // Initialize toggles for scaling points and opacity
        function initToggles() {
            const scalePointsToggle = document.getElementById('scale-points-toggle');
            const opacityToggle = document.getElementById('opacity-toggle');
            
            if (scalePointsToggle) {
                scalePointsToggle.checked = scalePointsByVotes;
                scalePointsToggle.addEventListener('change', function() {
                    scalePointsByVotes = this.checked;
                    renderMapData(); // Re-render with new settings
                });
            }
            
            if (opacityToggle) {
                opacityToggle.checked = useSolidPoints;
                opacityToggle.addEventListener('change', function() {
                    useSolidPoints = this.checked;
                    renderMapData(); // Re-render with new settings
                });
            }
        }
        
        // Clear the map
        function clearMap() {
            markersLayer.clearLayers();
            
            // Remove legend if it exists
            const legend = document.querySelector('.legend');
            if (legend) {
                legend.remove();
            }
        }
        
        // Reset the year selector
        function resetYearSelector() {
            yearSelect.innerHTML = '<option value="">Select Year</option>';
            yearSelect.disabled = true;
            resetElectionTypeSelector();
        }
        
        // Reset the election type selector
        function resetElectionTypeSelector() {
            electionTypeSelect.innerHTML = '<option value="">Select Election Type</option>';
            electionTypeSelect.disabled = true;
            clearMap();
        }
        
        // Reset all selectors
        function resetSelectors() {
            while (countrySelect.options.length > 1) {
                countrySelect.remove(1);
            }
            countrySelect.disabled = true;
            
            resetYearSelector();
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            initToggles();
            initLayerControls();
            
            // Add event listener for the load button
            loadMainIndexButton.addEventListener('click', loadMainIndex);
        });
    </script>
</body>
</html>